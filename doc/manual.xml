<?xml version="1.0" encoding="utf-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd"
[<!ENTITY SLA "<Package>SLA</Package>">] >




<Book Name="SLA">

<#Include SYSTEM "title.xml">

<TableOfContents/>

<Body>

<Chapter> <Heading>Introduction</Heading>

This package is a collection of functions that I wrote for various 
research projects (e.g., <Cite Key="wdg08"/>, <Cite Key="gra15"/>, 
<Cite Key="elasgra"/>, <Cite Key="grasss"/>, <Cite Key="closure"/>).
The reason to collect them in a package is to
avoid them getting lost. Secondly, I believe that the functions
may be of wider interest. <P/>
Apart from this one, this manual has five chapters. The second describes
various functions that have to do with root systems and Weyl groups. 
The third chapter describes some functions for semisimple Lie algebras and
their modules. The remaining chapters all deal with a particular area. <P/>


The fourth chapter contains (descriptions of) functions for computing 
with the classification of the nilpotent orbits in simple Lie algebras.
There are functions for creating the orbits and for computing representatives.
We refer to <Cite Key="colmcgov"/> for an overview of the theory of
nilpotent orbits in simple Lie algebras.
<P/>


The fifth chapter is dedicated to finite order automorphisms of the simple
Lie algebras and the
corresponding <M>\theta</M>-groups. The finite order automorphisms have
been classified by Kac, up to conjugacy in the automorphism group. 
For the background on this we refer to <Cite Key="helgason"/>.
The classification is described in terms of so-called Kac diagrams. 
The package contains a function for creating all automorphisms of a
given simple Lie algebra, of a given finite order. <P/>

The eigenspaces of an automorphism of finite order of a simple
Lie algebra form a grading of that Lie algebra. Moreover, the
0-component is a reductive subalgebra, acting on the 1-component.
The 0-component corresponds to a reductive reductive group, also acting
on the 1-component. This group (with its action) is called a 
<M>\theta</M>-group. It was introduced and studied in the 70-s by Vinberg
(<Cite Key="vinberg3"/> , <Cite Key="vinberg"/>, <Cite Key="vinberg2"/>)  
The package has a function for listing the
nilpotent orbits of this group. <P/>

The last chapter has functions for working with semisimple subalgebras
of semisimple Lie algebras. The package contains a database of semisimple
subalgebras of the simple subalgebras of ranks up to 8. Moreover, there
are functions for computing the semisimple subalgebras of semisimple Lie
algebras on the fly. Finally, there are some functions for computing
branching rules. <P/>
We remark that the package needs the package <Package>QuaGroup</Package>.




</Chapter>

<Chapter> <Heading>Root Systems and Weyl Groups</Heading>


This chapter contains the description of some functions for the
objects in the title of the chapter.


<Section> <Heading> Root Systems </Heading>

<ManSection>
   <Oper Name="ExtendedCartanMatrix"  Arg="R" 
         Comm="root system"/>
   <Description>

Here <A>R</A> is a root system. This function returns the extended Cartan
matrix of <A>R</A>. That is the Cartan matrix correponding to the 
lowest root (coming first), and the simple roots of <A>R</A>. <P/>
The output is a record with components <A>ECM</A> (the extended Cartan
matrix) and <A>labels</A> (the labels of the corresponding Dynkin diagram;
they are the integer coefficients of a linear dependency of the 
roots corresponding to the nodes).
<Example>
gap> R:= RootSystem("F",4);;
gap> ExtendedCartanMatrix(R);
rec( ECM := [ [ 2, -1, 0, 0, 0 ], [ -1, 2, -1, 0, 0 ], [ 0, -1, 2, -2, 0 ], 
      [ 0, 0, -1, 2, -1 ], [ 0, 0, 0, -1, 2 ] ], labels := [ 1, 2, 3, 4, 2 ] )
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CartanType"  Arg="C" 
         Comm="Cartan matrix"/>
   <Description>

Here <A>C</A> is a Cartan matrix (i.e., an integer matrix with 2-s on the  
diagonal, non-positive entries otherwise, and there exists a diagonal
integer matrix <A>D</A> such that <A>CD</A> is a positive definite 
symmetric matrix). This function returns a record with two components:
<A>types</A>, a list containing the types of the simple components of
the corresponding root system, and <A>enumeration</A>, a standard enumeration
of the vertices of the Dynkin diagram of <A>C</A>. 
So this can be used to construct isomorphisms of root systems.

<Example>
gap> C:= [[2,0,-3,0],[0,2,0,-1],[-1,0,2,0],[0,-1,0,2]];
[ [ 2, 0, -3, 0 ], [ 0, 2, 0, -1 ], [ -1, 0, 2, 0 ], [ 0, -1, 0, 2 ] ]
gap> CartanType(C);
rec( enumeration := [ [ 3, 1 ], [ 2, 4 ] ], 
  types := [ [ "G", 2 ], [ "A", 2 ] ] )
</Example>

</Description>
</ManSection>

<ManSection>
  <Oper Name="DisplayDynkinDiagram"  Arg="C" Comm="Cartan matrix"/>
   <Oper Name="DisplayDynkinDiagram"  Arg="R" Comm="Root system"
         Label="DisplayDynkinDiagramRootSystem"/>
   <Description>

Here <A>C</A> is a Cartan matrix. This function displays the Dynkin diagram of
the Cartan matrix. (Remark: this just works for Cartan matrices of root
systems, not for extended Cartan matrices.) <P/>

In the second form <A>R</A> is a root system. We display its Dynkin diagram.

<Example>
gap> C:=[[2,0,-1,0,0,0],[0,2,0,0,-3,0],[-1,0,2,0,0,-1],[0,0,0,2,0,-1],
> [0,-1,0,0,2,0],[0,0,-2,-1,0,2]];;
gap> DisplayDynkinDiagram(C); 
F4:  4---6=>=3---1
G2:  5#&lt;#2
</Example>

</Description>
</ManSection>



</Section>

<Section> <Heading> Weyl groups </Heading>



<ManSection>
   <Oper Name="WeylTransversal"  Arg="R, inds" 
         Comm="Root system and list"/>
   <Oper Name="WeylTransversal"  Arg="R, roots" 
         Comm="Root system and list" Label="WeylTransversalRoots"/>
   <Description>

Here <A>R</A> is a root system, and <A>inds</A> a list of indices of
<E>positive</E> roots of <A>R</A> that form a set of simple roots of
a root subsystem of <A>R</A> (the system does not check this). Here an
index of a positive root is its position in the list 
<A>PositiveRootsNF( R )</A>.<P/>
This function returns a list of shortest representatives of the right
cosets of the corresponding Weyl subgroup of the Weyl group of <A>R</A>.
The elements of the Weyl group are given as reduced expressions. <P/>
In the second form <A>rts</A> is a list of roots of <A>R</A>, that form
a set of simple roots of a root subsystem of <A>R</A> (again, this is
not checked). In this form the roots so not have to be positive.
They have to be represented with respect to the basis of simple roots,
i.e., they are elements of <A>PositiveRootsNF(R)</A> or of 
<A>NegativeRootsNF(R)</A>.


<Example>
gap> R:= RootSystem("A",3);;
gap> WeylTransversal( R, [2,6] );
[ [  ], [ 1 ], [ 3 ], [ 1, 2 ], [ 1, 3 ], [ 3, 2 ] ]
gap> R:= RootSystem("E",8);;
gap> p:= PositiveRootsNF(R);;
gap> a:= WeylTransversal( R, [p[1],p[3],p[4],p[5],p[6],p[7],p[8],-p[120]] );;
gap> Length(a);
1920
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="SizeOfWeylGroup"  Arg="R" />
   <Oper Name="SizeOfWeylGroup"  Arg="type" Label="SizeOfWeylGroupTypeList"/>
   <Oper Name="SizeOfWeylGroup"  Arg="X,n" Label="SizeOfWeylGroupTypeSing"/>
   <Description>

In the first from <A>R</A> is a root system. In the second
form <A>type</A> is a list of lists describing the type of a 
root system. For example: <A>[["A",3],["B",5],["G",2]]</A>. 
In the third form <A>X</A> is a letter (i.e., a string) and 
<A>n</A> a positive integer, so that <A> Xn</A> is the type of
a root system. In all cases the number of elements of the Weyl group
is returned.

<Example>
gap> R:= RootSystem( SimpleLieAlgebra("E",6,Rationals) );;
gap> SizeOfWeylGroup(R);                
51840
gap> SizeOfWeylGroup( [["E",6]] );
51840
gap> SizeOfWeylGroup( "E", 6 );   
51840
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="WeylGroupAsPermGroup"  Arg="R" />
   <Description>

Here <A>R</A> is a root system. This function returns a permutation group
whose set of elements is in bijection with the set of elements of the Weyl
group of <A>R</A>. More precisely, this bijection works as follows. <P/>

Let <M>n</M> be the number of positive roots of <A>R</A>. We list the
positive roots in the order in which they apppear in
<A>PositiveRootsNF( R )</A>. To this list we append the negative roots, listed
in the same order. Thus the list of roots is <M>\{\alpha_1,\ldots,\alpha_{2n}\}
</M>, where <M>\alpha_{i+n} = -\alpha_i</M> for <M>1\leq i\leq n</M>.
Then a reflection <M>s_\alpha</M> corresponding to the
root <M>\alpha</M> corresponds to the permutation <M>\pi_\alpha</M>, where
<M>s_\alpha( \alpha_i ) = \alpha_{i^{\pi_\alpha}}</M>. Note, however, that
<M>s_\alpha</M> acts from the <E>left</E>, whereas <M>\pi_\alpha</M> acts
from the <E>right</E>. Let <M>W</M> denote the Weyl group of <A>R</A> and
let <M>G</M> be the group generated by the permutations <M>\pi_\alpha</M>
for <M>\alpha</M> in the fixed set of simple roots of <A>R</A>. Then
mapping <M>s_\alpha</M> to <M>\pi_\alpha</M> extends to an
<E>anti-isomorphism</E> <M>W\to G</M>. The reason for doing it like this is
that in the vast majority of literature on Lie theory the Weyl group acts
from the left, but in &GAP; permutation groups act from the right.
When applying the group that is output by this function this difference
has to be kept in mind. For example, the orbit of a root <M>\beta</M> under
<M>W</M> equals the set of images of <M>\beta</M> under the representatives
of the left cosets of the stabilizer of <M>\beta</M>. But when we use the
group <M>G</M> we have to consider the right cosets for this.

<Example>
gap> R:= RootSystem("E",6);
&lt;root system of type E6>
gap> G:= WeylGroupAsPermGroup( R );
&lt;permutation group with 6 generators>
gap> Size(G);
51840
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="ApplyWeylPermToWeight"  Arg="R, p, w" />
   <Description>

     Here <A>R</A> is a root system, <A>p</A> is an element of the group 
     returned by <Ref Oper="WeylGroupAsPermGroup"/> with input <A>R</A>.
     Here <A>w</A> is a weight, that the list of coefficients of a weight
     when written as a linear combination of fundamental weights. This
     function returns the result of acting with the element of the Weyl group
     corresponding to <A>p</A> on <A>w</A>.

<Example>
gap> R:= RootSystem("D",4);;
gap> G:= WeylGroupAsPermGroup(R);
&lt;permutation group with 4 generators>
gap> wt:= ApplyWeylPermToWeight( R, Random(G), [1,1,1,1] );;
gap> ConjugateDominantWeight( WeylGroup(R), wt );
[ 1, 1, 1, 1 ] 
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="WeylWordAsPerm"  Arg="R, u" />
   <Description>

     Here <A>R</A> is a root system, and <A>u</A> is an element of the Weyl
     group given as a (not necessarily reduced) word, that is, <A>u</A> is
     given by a list of indices between 1 and the rank of <A>R</A>.
     This function returns the permutation corresponding to <A>u</A>, that is,
     the image of <A>u</A> under the anti-iromorphism discussed in
     <Ref Oper="WeylGroupAsPermGroup"/>.

<Example>
gap> R:= RootSystem("D",4);;
gap> WeylWordAsPerm( R, [1,2,1,3,4,2,3,4,1] );
(1,23,12,17)(2,10,14,22)(3,19,16,6)(4,18,15,7)(5,13,11,24)(8,21)(9,20)
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="PermAsWeylWord"  Arg="R, p" />
   <Description>

     This is the inverse operation to the one discussed in
     <Ref Oper="WeylWordAsPerm"/>. That is, the element of the Weyl group
     (this time given as reduced expression) corresponding to the permutation
     <A>p</A> is returned. <P/>
     In the next example we compute generators of the stabilizer of
     a subset of a root system. The generators are given as reduced words.

<Example>
gap> R:= RootSystem("D",4);;
gap> rts:= [1,3,4,12,13,15,16,24];;
gap> G:= WeylGroupAsPermGroup(R);;
gap> S:= Stabilizer( G, rts, OnSets );
&lt;permutation group of size 64 with 6 generators>
gap> Size(S);
64
gap> List( GeneratorsOfGroup(S), g -> PermAsWeylWord( R, g ) );
[ [ 3 ], [ 3, 4 ], [ 2, 1, 3, 2, 4, 2, 1, 3, 2, 4 ], [ 2, 1, 3, 2 ], 
  [ 2, 1, 4, 2 ], [ 1, 3 ] ]
</Example>

</Description>
</ManSection>


</Section>

</Chapter>

<Chapter> <Heading>Semisimple Lie Algebras and their Modules</Heading>

<Section> <Heading> Semisimple Lie algebras </Heading>

<ManSection>
   <Oper Name="IsomorphismOfSemisimpleLieAlgebras"  Arg="L1, L2"/>

<Description>

Here <A>L1</A> and <A>L2</A> are two semisimple Lie algebras that are
known to be isomorphic (i.e., they have the same type). This function
returns an isomorphism.

</Description>
</ManSection>

<ManSection>
   <Oper Name="DisplayDynkinDiagram"  Arg="L"
         Label="DisplayDynkinDiagramLieAlg"/>

<Description>

Here <A>L</A> is a semisimple Lie algebra. This function displays its
Dynkin diagram.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);
&lt;Lie algebra of dimension 52 over Rationals>
gap> DisplayDynkinDiagram(L);              
F4:  2---4=>=3---1
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="ApplyWeylPermToCartanElement"  Arg="L, w, h"/>

<Description>

Here <A>L</A> is a semisimple Lie algebra, <A>w</A> is a permutation which is
an element of <A>WeylGroupAsPermGroup( RootSystem(L) )</A>, and <A>h</A> is
an element of the Cartan subalgebra <A>CartanSubalgebra( L )</A>. The Weyl
groups naturally acts on this Cartan subalgebra and this function returns
the result of applying <A>w</A> to <A>h</A>.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> R:= RootSystem(L);;
gap> W:= WeylGroupAsPermGroup(R);;
gap> w:= Product( GeneratorsOfGroup(W) );
(1,32,33,36,35,27,25,8,9,12,11,3)(2,30,34,44,37,39,26,6,10,20,13,15)(4,16,23,24,22,18,28,
40,47,48,46,42)(5,31,41,43,45,38,29,7,17,19,21,14)
gap> H:= CartanSubalgebra(L);;
gap> h:= Sum( Basis(H) );
v.49+v.50+v.51+v.52
gap> ApplyWeylPermToCartanElement( L, w, h );
(-1)*v.52
</Example>

</Description>
</ManSection>


</Section>

<Section> <Heading> Representations of semisimple Lie algebras </Heading>

<ManSection>
   <Oper Name="AdmissibleLattice"  Arg="V"/>

<Description>

Here <A>V</A> is a <E>simple</E> module over a semisimple Lie algebra.
This function returns a basis
of <A>V</A> that spans an admissible lattice in <A>V</A>. This means
that for a root vector <M>x</M> of the acting Lie algebra the
matrix <M>exp( mx )</M> is integral, where <M>mx</M> denotes the matrix
of <M>x</M> relative to the admissible lattice.

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [2,0] );
&lt;27-dimensional left-module over &lt;Lie algebra of dimension 14 over Rationals>>
gap> B:=AdmissibleLattice(V);;
gap> x:= L.1;
v.1
gap> mx:= MatrixOfAction( B, x );;
gap> IsZero(mx^4); IsZero(mx^5);
false
true
gap> exp:=Sum( List( [0..4], i -> mx^i/Factorial(i) ) );;
gap> ForAll( Flat(exp), IsInt );
true
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DirectSumDecomposition"  Arg="V"/>

<Description>

Here <A>V</A> is a module over a semisimple Lie algebra; this function
computes a list of sub-modules such that <A>V</A> is their direct sum.

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [1,0] );;
gap> W:= TensorProductOfAlgebraModules( V, V );
&lt;49-dimensional left-module over &lt;Lie algebra of dimension 14 over Rationals>>
gap> DirectSumDecomposition( W );
[ &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>> ]
gap> List( last, Dimension );
[ 27, 7, 14, 1 ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="IsIrreducibleHWModule"  Arg="V"/>

<Description>

Returns <A>true</A> if <A>V</A> is an irreducible module over a semisimple
Lie algebra, and <A>false</A> otherwise  

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);
&lt;Lie algebra of dimension 52 over Rationals>
gap> V:= HighestWeightModule( L, [0,1,0,0] );
&lt;52-dimensional left-module over &lt;Lie algebra of dimension 52 over Rationals>>
gap> IsIrreducibleHWModule(V);
true
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="HighestWeightVector"  Arg="V"/>

<Description>

Here <A>V</A> is an irreducible module over a semisimple Lie algebra.
This function returns a highest weight vector <A>v0</A> in <A>V</A>. This means
that it is a weight vector for the Cartan subalgebra of the acting Lie
algebra, and all positive root vectors send it to zero.


<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [1,0] );;
gap> W:= TensorProductOfAlgebraModules( V, V );;
gap> dW:= DirectSumDecomposition( W );;
gap> cg:= CanonicalGenerators( RootSystem(L) );;
gap> v0:= HighestWeightVector( dW[3] );
1*(1*v0&lt;x>y1*v0)-1*(y1*v0&lt;x>1*v0)
gap> List( cg[3], h -> h^v0 );
[ &lt;0-tensor>, 1*(1*v0&lt;x>y1*v0)-1*(y1*v0&lt;x>1*v0) ]
gap> List( cg[1], h -> h^v0 );
[ &lt;0-tensor>, &lt;0-tensor> ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="HighestWeight"  Arg="V"/>

<Description>

Here <A>V</A> is an irreducible module over a semisimple Lie algebra.
This function returns the highest weight of <A>V</A>. That is, the list of
eigenvalues of the Cartan elements in a canonical generating set of the
Lie algebra, when acting on a highest weight vector.

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [1,0] );;
gap> W:= TensorProductOfAlgebraModules( V, V );;
gap> dW:= DirectSumDecomposition( W );;
gap> List( dW, HighestWeight );
[ [ 2, 0 ], [ 1, 0 ], [ 0, 1 ], [ 0, 0 ] ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DisplayHighestWeight"  Arg="V"/>

<Description>
Here <A>V</A> is an irreducible module over a semisimple Lie algebra.
This function displays its highest weight, that is, it shows the coordinates of
the highest weight on the Dynkin diagram of the Lie algebra.

<Example>
gap> r:= LieAlgebraAndSubalgebras( "E8" );;
gap> L:= r.liealg;;
gap> K:= r.subalgs[823];
&lt;Lie algebra of dimension 58 over CF(84)>
gap> DisplayDynkinDiagram(K);
A1:  1
B5:  2---3---4---5=>=6
gap> V:= AdjointModule( L );
&lt;248-dimensional left-module over &lt;Lie algebra of dimension 248 over CF(84)>>
gap> W:= ModuleByRestriction( V, K );
&lt;248-dimensional left-module over &lt;Lie algebra of dimension 58 over CF(84)>>
gap> dW:= DirectSumDecomposition( W ); 
[ &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 58 over CF(84)>> ]
gap> List( dW, Dimension );
[ 33, 3, 3, 3, 64, 64, 11, 11, 55, 1 ]
gap> DisplayHighestWeight( dW[5] );
A1:  1
B5:  0---0---0---0=>=1
gap> DisplayHighestWeight( dW[1] );
A1:  2
B5:  1---0---0---0=>=0
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="IsomorphismOfIrreducibleHWModules"  Arg="V1, V2"/>

<Description>

Here <A>V1</A>, <A>V2</A> are two irreducible modules over the same semisimple
Lie algebra with the same highest weights. This function returns an isomorphism
between the two. 

<Example>
gap> r:= LieAlgebraAndSubalgebras( "E8" );;
gap> L:= r.liealg;;
gap> K:= r.subalgs[823];;
gap> DisplayDynkinDiagram(K);
A1:  1
B5:  2---3---4---5=>=6
gap> V:= AdjointModule( L );;
gap> W:= ModuleByRestriction( V, K );;
gap> dW:= DirectSumDecomposition( W );;
gap> DisplayHighestWeight( dW[5] );
A1:  1
B5:  0---0---0---0=>=1
gap> DisplayHighestWeight( dW[6] );
A1:  1
B5:  0---0---0---0=>=1
gap> f:= IsomorphismOfIrreducibleHWModules( dW[5], dW[6] );;
gap> Image( f, HighestWeightVector( dW[5] ) );
v.205
gap> HighestWeightVector( dW[6] );
v.205
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DualAlgebraModule"  Arg="V"/>

<Description>

Here <A>V</A> is a module over a Lie algebra. This function returns the
dual module. <P/>

The basis elements of this module are printed as <A>F@v</A> where <A>v</A> is
a basis element of <A>v</A>. This represents the function which takes the value
1 on te basis element <A>v</A> and 0 on all other basis elements. However,
an element of the module is a module element and not a function. We can
access the function by taking the <A>ExtRepOfObj</A> of an element of the
module, as illustrated by the example below.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> V:= HighestWeightModule( L, [0,0,1,0,0,0] );; Dimension(V);
351
gap> Vst:= DualAlgebraModule( V );
&lt;351-dimensional left-module over &lt;Lie algebra of dimension 78 over Rationals>>
gap> DisplayHighestWeight( Vst );
             0
             |
E6:  0---0---0---1---0
gap> DisplayHighestWeight( V );  
             0
             |
E6:  0---1---0---0---0
gap> v0:= HighestWeightVector( Vst );
(1)*F@y15*y23*y36^(2)*v0
gap> f:= ExtRepOfObj( v0 );         
(1)*F@y15*y23*y36^(2)*v0
gap> Image(f, Basis(V)[10] );
0
</Example>


</Description>
</ManSection>


<ManSection>
   <Oper Name="CharacteristicsOfStrata"  Arg="L, hw"/>
   <Oper Name="CharacteristicsOfStrata"  Arg="L, B, hw"
         Label="CharacteristicsOfStrataBLForm"/>
<Description>

Here <A>L</A> is a semisimple Lie algebra over a field of characteristic 0.
Secondly, <A>hw</A> is a dominant weight, represented as a list of non-negative
integers (where the ordering of the fundamantal weights is given by the
Cartan matrix of the root system of <A>L</A>). Let <M>G</M> denote the 
semisimple algebraic group acting on the irreducible representation with
highest weight <A>hw</A>. Alternatively, <A>hw</A> can also be a list of
highest weights, in which case the representation is the direct sum of the
irreducible representations with highest weights in the list. 

Hesselink (<Cite Key="hesselink"/>)
defined a stratification of the nullcone relative to the action of <M>G</M>. 
Popov and Vinberg (<Cite Key="povin"/>) have described this
stratification in terms of characteristics, which are elements of a Cartan
subalgebra of <A>L</A>. To each characteristic there corresponds a stratum.
This function is an implementation of an algorithm due to Popov
(<Cite Key="popov"/>), for computing the characteristics of the strata. It
returns a list of two lists. The first list contains the 
characteristics. The second list contains the dimensions of the corresponding 
strata. If the highest weight <A>hw</A> defines the adjoint representation,
then the characteristics of the strata are exactly the characteristics
of the nilpotent orbits in <A>L</A>. This means the following: let <M>h</M> be
a characteristic, then there are <M>e,f</M> in <A>L</A> such that the triple
<M>h,e,f</M> satisfies the commutation relations of <M>\mathfrak{sl}_2</M>,
and the elements <M>e</M> thus obtained are the representatives of the
nilpotent <M>G</M>-orbits in <A>L</A>. <P/>

We remark that the characteristics depend on the choice of an invariant bilinear
form. This form is unique if <A>L</A> is simple. If we give just two arguments,
<A>L</A>, <A>hw</A>, then Killing form is chosen.
It is possible to use a different form using the three argument variant of the
function. <P/>

In the three argument variant <A>L</A> is a reductive Lie algebra and <A>B</A>
is the restriction of a non-degenerate invariant bilinear form on the Cartan
subalgebra of <A>L</A>. This bilinear form must be given with respect to
a specific basis, which we now describe. Let <A>K</A> denote the derived
subalgebra of <A>L</A> (which is semisimple). Let <A>h</A> be the list
<A>CanonicalGenerators( RootSystem( K ) )[3]</A> (this is a basis of a
Cartan subalgebra of <A>K</A>). Let <A>c</A> be the list
<A>BasisVectors( Basis( LieCentre(K) ) )</A>. Then the basis we require
is the concatenation of <A>h</A> and <A>c</A>. Again <A>hw</A> can be a highest
weight, or a list of highest weights. These highest weights are lists of
eigenvalues of the elements of the particular basis of a Cartan subalgebra of
<A>L</A> described above.
 

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> CharacteristicsOfStrata( L, [0,1] );
[ [ v.13+(2)*v.14, (2)*v.13+(3)*v.14, (2)*v.13+(4)*v.14, (6)*v.13+(10)*v.14 ],
  [ 6, 8, 10, 12 ] ]
</Example>

In the next example we compute the strata of a representation of a reductive
subalgebra of the Lie algebra of type <M>E_6</M>, obtained as the set of
fixed points of an inner automorphism. We compute the strata of the 
<M>\theta</M>-representation corresponding to the automorphism. For this we
first need to work out the highest weights of the module. The bilinear form
is the restriction of the Killing form to the subalgebra.

<Example>
gap> f:= FiniteOrderInnerAutomorphisms("E",6,3)[2];;
gap> M:= Source(f);;
gap> gr:= Grading(f);;
gap> L:= Subalgebra(M,gr[1]);
&lt;Lie algebra over CF(3), with 28 generators>
gap> K:= LieDerivedSubalgebra( L );
&lt;Lie algebra of dimension 27 over CF(3)>
gap> V:= LeftAlgebraModuleByGenerators( K, function(x,v) return x*v; end, gr[2]); 
&lt;left-module over &lt;Lie algebra of dimension 27 over CF(3)>>
gap> DisplayDynkinDiagram( K ); 
A4:  1---4---3---2
A1:  5
gap> dV:= DirectSumDecomposition(V);
[ &lt;left-module over &lt;Lie algebra of dimension 27 over CF(3)>>, 
  &lt;left-module over &lt;Lie algebra of dimension 27 over CF(3)>> ]
gap> DisplayHighestWeight( dV[1] );        
A4:  0---0---0---1
A1:  0
gap> DisplayHighestWeight( dV[2] );
A4:  0---0---1---0
A1:  1
gap> t0:= Basis(LieCentre(L))[1];
v.73+(4/5)*v.75+(3/5)*v.76+(2/5)*v.77+(1/5)*v.78
gap> HighestWeightVector( dV[1] ); t0^last;
v.7
(6/5)*v.7
gap> HighestWeightVector( dV[2] ); t0^last;
v.13
(-3/5)*v.13
gap> hw:= [ [0,1,0,0,0,6/5], [0,0,1,0,1,-3/5] ]; 
[ [ 0, 1, 0, 0, 0, 6/5 ], [ 0, 0, 1, 0, 1, -3/5 ] ]
gap> bas:= Concatenation( CanonicalGenerators( RootSystem(K) )[3],
> Basis(LieCentre(L)) );;
gap> B:= List( bas, x -> [] );;
gap> ad:= List( bas, x -> AdjointMatrix( Basis(M), x ) );;
gap> for i in [1..Length(B)] do for j in [i..Length(B)] do
> B[i][j]:= TraceMat( ad[i]*ad[j]); B[j][i]:= B[i][j];
> od; od;
gap> B;
[ [ 48, 0, 0, -24, 0, 0 ], [ 0, 48, -24, 0, 0, 0 ], [ 0, -24, 48, -24, 0, 0 ], 
[ -24, 0, -24, 48, 0, 0 ], [ 0, 0, 0, 0, 48, 0 ], [ 0, 0, 0, 0, 0, 144/5 ] ]
gap> CharacteristicsOfStrata( L, B, hw );
[ [ v.74+v.75+v.76, v.73+v.75, (-2)*v.73, 
      (2)*v.74+(2)*v.75+(3)*v.76+(2)*v.77+v.78, (-1)*v.73+(-1)*v.76+(-1)*v.77,
      v.73+v.74+(2)*v.75+v.76, (2)*v.73+(2)*v.74+(4)*v.75+(4)*v.76+(2)*v.77+(
        2)*v.78, (-2)*v.73+v.74, v.74+(4)*v.75+(2)*v.76+v.77+v.78, 
      (-1)*v.73+v.74+v.75+v.76, (2)*v.73+(3)*v.74+(5)*v.75+(5)*v.76+(3)*v.77+(
        2)*v.78, v.73+(4)*v.75+v.76, v.75+(-1)*v.76+(-1)*v.77, 
      v.73+v.74+(3)*v.75+(2)*v.76+v.78, (4)*v.73+(6)*v.74+(7)*v.75+(9)*v.76+(
        6)*v.77+(3)*v.78, (-3)*v.73+(-2)*v.75+(-2)*v.76+(-2)*v.77+(-1)*v.78, 
      (4)*v.75+(2)*v.76, (2)*v.73+(6)*v.74+(8)*v.75+(8)*v.76+(4)*v.77+(2)*v.78
        , (2)*v.74+(4)*v.75+(2)*v.76+v.77+v.78, 
      (2)*v.74+(4)*v.75+(2)*v.76+(-2)*v.77, 
      v.73+v.74+(5)*v.75+(3)*v.76+v.77+v.78, 
      v.73+(2)*v.74+(4)*v.75+(3)*v.76+v.77+v.78, 
      (4)*v.73+(6)*v.74+(10)*v.75+(10)*v.76+(4)*v.77+(4)*v.78, 
      (3)*v.73+(6)*v.74+(10)*v.75+(10)*v.76+(5)*v.77+(5)*v.78, 
      (-1)*v.73+v.74+(3)*v.75+(-3)*v.77+(-1)*v.78, 
      (6)*v.74+(10)*v.75+(8)*v.76+(2)*v.77+(2)*v.78 ], 
  [ 8, 5, 16, 11, 12, 10, 13, 18, 18, 15, 15, 17, 13, 15, 16, 20, 20, 20, 19, 
      21, 19, 17, 20, 22, 22, 24 ] ]
</Example>



</Description>
</ManSection>


</Section>


</Chapter>


<Chapter> <Heading>Nilpotent Orbits</Heading>

This chapter contains functions for dealing with the nilpotent orbits of a
semisimple Lie algebra <M>K</M> under its adjoint group <M>G</M>. We refer
to the book by Collingwood and McGovern,  <Cite Key="colmcgov"/>
(and the references therein) for an account of the theory of nilpotent orbits.

A nilpotent orbit has two important attributes: the weighted Dynkin diagram,
and an <M>sl_2</M>-triple. The weighted Dynkin diagram is represented by a list of 
integers in {0,1,2} of length equal to the rank of the Lie algebra. The i-th 
position in this list correponds to the i-th node of the Dynkin diagram of the 
root system. The Dynkin diagram of the root system is described by the Cartan 
matrix of the root system. Now in GAP this Cartan matrix can be somewhat 
different from the more usual forms. This holds most particularly for type F4, 
where the enumeration of the simple roots is rather different from the one 
usually found. So when using the functions in this chapter one should keep this 
in mind.
<P/>
Every nilpotent orbit has an <M>sl_2</M>-triple, that is a triple <M>(y,h,x)</M> of 
elements of the simple Lie algebra with <M>[x,y]=h</M>, 
<M>[h,x]=2x</M>, <M>[h,y]=-2y</M>. The 
nilpotent orbit corresponding to this is the orbit
of the element x under the action of the adjoint group. 
<P/>
Let <M>P</M> be a parabolic subalgebra of <M>K</M>
(i.e., generated by the Cartan subalgebra of <M>K</M>,
all positive root vectors, along with the negative simple
root vectors corresponding to a given subset of the basis of simple
roots), <M>L</M> the corresponding Levi subalgebra (i.e., the reductive part of 
<M>P</M>), and <M>N</M> the nilradical of <M>P</M>. Let <M> O_L</M> be a nilpotent
orbit in <M>L</M>. There exists a 
unique nilpotent orbit <M>O_K</M> in <M>K</M> such that the intersection of 
<M>O_K</M> and <M>O_L + N</M> is dense in the latter. In this situation <M>O_K</M> is
said to be <E>induced</E> from <M>O_L</M>. Nilpotent orbits in <M>K</M> which are not 
induced are said to be <E>rigid</E>. 
<P/>
Now consider the variety of all <M>G</M>-orbits in <M>K</M> of a given dimension
<M>d</M>. The irreducible components of this variety are called the <E>sheets</E>
of <M>K</M>. Every sheet has a unique nilpotent
orbit. Moreover this nilpotent orbit is induced from an orbit <M>O_L</M>, and
<M>O_L</M> is rigid in <M>L</M>. So the sheets are parametrised by pairs 
<M>(L,O_L)</M>, where <M>L</M> is a Levi subalgebra, and <M>O_L</M> a rigid nilpotent
orbit in it. This data can conveniently be given by a <E>sheet diagram</E>:
this is the Dynkin diagram of <M>K</M>, were the nodes that do <E>not</E> correspond
to simple roots of <M>L</M> have label 2. So, leaving out the nodes with label 2, one
obtains the Dynkin diagram of <M>L</M>. The remaining labels in the sheet diagram
then correspond to the weighted Dynkin diagram of the nilpotent orbit <M>O_L</M>.
Since this orbit is rigid, its weighted Dynki diagram has labels 0 or 1. From that
it follows that one can recover <M>L</M> and <M>O_L</M> from the sheet diagram.
The <E>rank</E> of a sheet is defined as the dimension of the centre of <M>L</M>,
obviously that is equal to the number of 2's in the sheet diagram.



<Section> <Heading> The functions </Heading>

<ManSection>
   <Oper Name="NilpotentOrbit"  Arg="L, wd" 
         Comm="Lie algebra and weighted Dynkin diagram"/>
   <Description>

Here <A>L</A> is a simple Lie algebra and <A>wd</A> a weighted Dynkin
diagram (i.e., a list containing the weights of the weighted Dynkin
diagram, in the same order as the nodes of the Dynkin diagram of 
the root system of <A>L</A>; that order can be deduced from the Cartan
matrix of the same root system).
The corresponding nilpotent orbit is returned. It is the responsibility
of the user to make sure that the weighted Dynkin diagram corresponds to a 
nilpotent orbit.
<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> o:= NilpotentOrbit( L, [1,2,0,0,0,1] );
&lt;nilpotent orbit in Lie algebra of type E6>
</Example>

</Description>
</ManSection>


<ManSection>
   <Attr Name="NilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra. This function returns the
list of all nilpotent orbits of <A>L</A>. 

If <A>L</A> is simple of classical type, then the nilpotent orbits correpond
to partitions (of <M>n+1</M> for type <M>A_n</M>, of <M>2n+1</M> for type
<M>B_n</M>, of <M>2n</M> for type <M>C_n</M> and of <M>2n</M> for type
<M>D_n</M>, see <Cite Key="colmcgov"/>). If <A>L</A> is of one of these
types then the orbits returned by this function have the attribute
<A>OrbitPartition</A> set, which returns the corresponding partition.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> orbs[10];
&lt;nilpotent orbit in Lie algebra of type E6>
gap> Length(orbs);
20
gap> L:= SimpleLieAlgebra("B",4,Rationals);;
gap> orbs:= NilpotentOrbits(L);;            
gap> OrbitPartition( orbs[10] );
[ 5, 3, 1 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="WeightedDynkinDiagram"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns its weighted
Dynkin diagram.

</Description>
</ManSection>

<ManSection>
   <Meth Name="WeightedDynkinDiagram"  Arg="L, x" 
         Comm="Lie algebra and nilpotent element"
         Label="WeightedDynkinDiagramLieAlg"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra, and <A>x</A> a nilpotent element.
This function returns the weighted Dynkin diagram of the orbit containing 
<A>x</A>. 

<Example>
gap> L:= SimpleLieAlgebra("B",3,Rationals);;
gap> WeightedDynkinDiagram( L, L.1+L.9 ); 
[ 2, 0, 0 ]
gap> L:= SimpleLieAlgebra("E",6,Rationals );;
gap> WeightedDynkinDiagram(L, L.1+L.6+L.20+2*L.32 : table:= true );
[ 0, 0, 0, 1, 0, 0 ]
</Example>

</Description>
</ManSection>


<ManSection>
   <Meth Name="DisplayWeightedDynkinDiagram"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

This displays the weighted Dynkin diagram of the nilpotent orbit <A>o</A> on
the Dynkin diagram of the Lie algebra.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> no:= NilpotentOrbits(L);;
gap> DisplayWeightedDynkinDiagram( no[10] );
             1
             |
E6:  0---1---0---1---0
</Example>

</Description>
</ManSection>

<ManSection>
   <Meth Name="DisplayWeightedDynkinDiagram"  Arg="L, x"
         Label="DisplayWeightedDynkinDiagramLieAlg"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra with nilpotent element <A>x</A>.
This displays the weighted Dynkin diagram of the nilpotent orbit containing
<A>x</A> on the Dynkin diagram of the Lie algebra.

<Example>
gap> K1:= SimpleLieAlgebra("B",3,Rationals);;                                         
gap> K2:= SimpleLieAlgebra("F",4,Rationals);;
gap> L:= DirectSumOfAlgebras( K1, K2 );;
gap> x:=L.1+L.3+L.17+L.33;
v.1+v.3+v.17+v.33
gap> DisplayWeightedDynkinDiagram( L, x );
B3:  2---2=>=2
F4:  0---0=>=0---1
</Example>

</Description>
</ManSection>



<ManSection>
   <Attr Name="AmbientLieAlgebra"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns the Lie algebra
it lives in.

</Description>
</ManSection>

<ManSection>
   <Attr Name="SemiSimpleType"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns the type of the 
Lie algebra it lives in.

</Description>
</ManSection>


<ManSection>
   <Attr Name="SL2Triple"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns an sl_2-triple
<M>(y,h,x)</M> corresponding to <A>o</A>. For the exceptional types the 
<M>x</M> is as in the paper <Cite Key="wdg08"/>. For the classical types
the <M>x</M> is computed on the fly.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> SL2Triple( orbs[10] );
[ (4)*v.51+(3)*v.53+(3)*v.56+v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.15+v.17+v.20+v.23 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="RandomSL2Triple"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns a random sl_2-triple
<M>(x,h,y)</M> corresponding to <A>o</A>. This means that every call
(potentially) returns a different sl_2-triple.


<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> RandomSL2Triple( orbs[10] );
[ (3)*v.49+(3)*v.50+v.51+(4)*v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.13+v.14+v.15+v.23 ]
gap> RandomSL2Triple( orbs[10] );
[ (3)*v.49+(4)*v.54+(3)*v.56+v.57, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.13+v.18+v.20+v.21 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SL2Grading"  Arg="L, h" 
         Comm="Lie algebra and nuetral element of sl_2 triple"/>
   <Description>

Here <A>L</A> is a Lie algebra, and <A>h</A> is an element of it, such
that there is an sl_2 triple of which it is the Cartan element (the system
does not check that). This function returns the grading of <A>L</A> in
eigenspaces of <A>h</A>.

A list containing three lists is returned:
the first list contains bases of the components with degrees 1,2,3,... the
second list has bases of the components with degrees -1,-2,-3,..., the
last list contains a basis of the zero component.


<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> sl2:= RandomSL2Triple( orbs[6] );
[ (2)*v.37+(2)*v.39+v.41, (3)*v.49+(4)*v.50+(6)*v.51+(8)*v.52, v.13+v.15+v.17 
 ]
gap> SL2Grading( L, sl2[2] );
[ [ [ v.3, v.5, v.7, v.8, v.9, v.11 ], 
      [ v.10, v.12, v.13, v.14, v.15, v.16, v.17, v.18, v.20 ], 
      [ v.19, v.21 ], [ v.22, v.23, v.24 ] ], 
  [ [ v.27, v.29, v.31, v.32, v.33, v.35 ], 
      [ v.34, v.36, v.37, v.38, v.39, v.40, v.41, v.42, v.44 ], 
      [ v.43, v.45 ], [ v.46, v.47, v.48 ] ], 
  [ v.1, v.2, v.4, v.6, v.25, v.26, v.28, v.30, v.49, v.50, v.51, v.52 ] ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SL2Triple"  Arg="L, x" 
         Comm="Lie algebra and nilpotent element" Label="SL2TripleLieAlg"/>
   <Description>

Here <A>L</A> is a simple Lie algebra, and <A>x</A> is a nilpotent 
element of it. A list of three elements is returned, forming an 
sl_2-triple, the last of which is equal to <A>x</A>.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> SL2Triple( L, L.1+L.20 );
[ v.16+v.25, v.49, v.1+v.20 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Attr Name="Dimension"  Arg="o" />
   <Description>

Returns the dimension of the nilpotent orbit <A>o</A>.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> no:= NilpotentOrbits(L);;
gap> Dimension( no[13] );                 
60
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="IsRegular"  Arg="o" /> 

   <Description>

The regular nilpotent orbit is the one of maximal dimension. This function
returns <A>true</A> if the nilpotent orbit <A>o</A> is regular, <A>false</A>
otherwise.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> no:= NilpotentOrbits(L);;
gap> IsRegular( no[13] );
false
gap> IsRegular( no[20] );
true
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="RegularNilpotentOrbit"  Arg="L" /> 

   <Description>

Here <A>L</A> is a semisimple Lie algebra. This function returns the regular
nilpotent orbit of <A>L</A>. 

</Description>
</ManSection>

<ManSection>
   <Oper Name= "IsDistinguished"  Arg="o" /> 

   <Description>

A nilpotent orbit is said to be distinguished if for a representative <A>x</A>
we have that the only Levi subalgebra containing <A>x</A> is the ambient
Lie algebra itself. This function returns <A>true</A> if the nilpotent
orbit <A>o</A> is distinguished, <A>false</A> otherwise.


<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> no:= NilpotentOrbits(L);;
gap> IsDistinguished( no[10] );
false
gap> IsDistinguished( no[17] );
true
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="DistinguishedNilpotentOrbits"  Arg="L" /> 

   <Description>

Returns the list of distinguished nilpotent orbits of <A>L</A>.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> dis:= DistinguishedNilpotentOrbits( L );; Length(dis);
3
gap> DisplayWeightedDynkinDiagram( dis[1] );
             0
             |
E6:  2---0---2---0---2
gap> DisplayWeightedDynkinDiagram( dis[2] );
             2
             |
E6:  2---2---0---2---2
gap> DisplayWeightedDynkinDiagram( dis[3] );
             2
             |
E6:  2---2---2---2---2
</Example>
</Description>
</ManSection>


<ManSection>
   <Attr Name="ComponentGroup"  Arg="o" />
   <Description>

Here <A>o</A> is a nilpotent orbit in a <E>simple</E> Lie algebra <A>L</A>.
Let <A>(f,h,e)</A> be an <M>\mathfrak{sl}_2</M>-triple as returned by 
<A>SL2Triple( o )</A>. We consider the stabilizer <M>S</M> of <A>(f,h,e)</A> 
in the
adjoint group <M>G</M> of <A>L</A>. This stabilizer consists of the elements 
in <M>G</M> that map each of <A>f, h, e</A> to itself. This function
returns a subgroup of <M>G</M> that in all but four cases (see below) is 
isomorphic to
the component group of <M>S</M>. The elements of this group are 
given by their matrices relative to the basis <A>Basis( L )</A> of <A>L</A>.
<P/>

In four cases (one in type <M>E_7</M> and three in type <M>E_8</M>) the group
returned has order 4, whereas the component group <M>S/S^\circ</M> has
order 2. In these cases the square of a generator of the returned group
lies in <M>S^\circ</M>. <P/>

We remark that it is known that the component group of <M>S</M> is the same
as the component group of the stabilizer of <A>e</A>. 
<P/>

In the next example we construct the automorphisms that correspond to 
the generators of a component group.



<Example>
gap> L:= SimpleLieAlgebra("E",8,Rationals);;
gap> no:= NilpotentOrbits(L);; 
gap> C:= ComponentGroup( no[41] ); 
&lt;matrix group with 2 generators>
gap> Length( Elements(C) );
120
gap> gens:= GeneratorsOfGroup(C);;
gap> f1:= function(x) return (gens[1]*Coefficients(Basis(L),x))*Basis(L); end;
function( x ) ... end
gap> f2:= function(x) return (gens[2]*Coefficients(Basis(L),x))*Basis(L); end;
function( x ) ... end
gap> sl2:= SL2Triple( no[41] );;
gap> List( sl2, f1 ) = sl2;
true
gap> List( sl2, f2 ) = sl2;
true
</Example>

</Description>
</ManSection>




<ManSection>
   <Attr Name="InducedNilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a simple Lie algebra. This function returns the
list of all induced nilpotent orbits of <A>L</A>.  
An induced orbit is given by a record containing
two fields: <A>sheetdiag</A>, which is a diagram describing the Levi subalgebra and the 
rigid nilpotent orbit in it from which the nilpotent orbit is induced, and <A>norbit</A>,
which is the induced nilpotent orbit in <A>L</A>. 

The sheet diagram is a labeled Dynkin diagram, and the labels are 0, 1 or 2. 
If we take the Dynkin diagram and erase the nodes which have label 2 then we obtain
the Dynkin diagram of the Levi subalgebra. Moreover, the labels 0 and 1 on that diagram 
give the rigid nilpotent orbit in the Levi subalgebra. From this pair the nilpotent
orbit <A>norbit</A> is induced.

It may happen that the same nilpotent orbit is induced from more pairs consisting of a 
Levi subalgebra and a rigid nilpotent orbit in it. In that case the same nilpotent
orbit appears more than once in the list, each time with a different sheet diagram 
attached.

This function works for the Lie algebras of exceptional type and for the Lie 
algebras of type <M>A</M> regardless of the rank. It works for the Lie algebras 
of the other types up to rank 10.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> s:= InducedNilpotentOrbits(L);;
gap> s[19];
rec( norbit := &lt;nilpotent orbit in Lie algebra of type E6>, 
  sheetdiag := [ 2, 0, 0, 1, 0, 2 ] )
gap> WeightedDynkinDiagram( s[19].norbit );
[ 0, 0, 0, 2, 0, 0 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="RigidNilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a simple Lie algebra. This function returns the
list of all rigid nilpotent orbits of <A>L</A>, <E>except</E> the zero orbit
(which is always rigid).

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> RigidNilpotentOrbits(L);
[ &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6> ]
gap> List( last, WeightedDynkinDiagram );
[ [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 1 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="RichardsonOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a simple Lie algebra. A nilpotent orbit is said to be 
Richardson if it is induced from the zero orbit in a Levi subalgebra. 
This function returns the list of all Richardson nilpotent orbits of <A>L</A>.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> RichardsonOrbits(L);
[ &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, &lt;nilpotent orbit in Lie algebra of type E6> ]
gap> List( last, WeightedDynkinDiagram );    
[ [ 2, 2, 2, 2, 2, 2 ], [ 2, 2, 2, 0, 2, 2 ], [ 2, 2, 0, 2, 0, 2 ], [ 1, 2, 1, 0, 1, 1 ], 
  [ 1, 2, 0, 0, 0, 1 ], [ 1, 0, 0, 0, 0, 1 ], [ 0, 0, 1, 0, 1, 0 ], [ 1, 1, 1, 0, 1, 1 ], 
  [ 0, 0, 0, 2, 0, 0 ], [ 2, 0, 0, 2, 0, 2 ], [ 2, 2, 0, 0, 0, 2 ], [ 0, 2, 0, 0, 0, 0 ], 
  [ 0, 2, 0, 2, 0, 0 ], [ 2, 0, 0, 0, 0, 2 ] ]
</Example>

</Description>
</ManSection>



</Section>

</Chapter>

<Chapter> <Heading>Finite Order Automorphisms and <M>\theta</M>-Groups</Heading>

This chapter contains functions for creating and working with
finite order automorphisms of simple Lie algebras (or, more precisely,
representatives of the conjugacy classes of such automorphisms). <P/>

NB: such automorphisms are not created for a given Lie algebra, but
the Lie algebra is constructed at the same time as the automorphism.
This because the base field may need extending (it needs enough roots of 
unity). <P/>

As noted above the functions give representatives of the conjugacy
classes, in the automorphism group of the underlying Lie algebra,
of finite order automorphisms. Such conjugacy classes are classified in
terms of Kac diagrams. Roughly, this works as follows. A finite order
automorphism <M>f</M> 
corresponds to a diagram automorphism of order <M>d=1,2,3</M>.
The inner automorphisms correspond to a diagram automorphism of 
order 1, the outer automorphisms to a diagram automorphism of
order 2 or 3. Let <M>L_0, L_1</M> denote the eigenspaces of the underlying
Lie algebra <M>L</M>, with respect to the diagram automorphism, respectively
corresponding to the eigenvalues 1 and <M>w</M> (where <M>w</M> is a 
primitive <M>d</M>-th root of unity). (In case of <M>d=1</M>, we have
<M>L_0=L</M>, <M>L_1=0</M>.) Then <M>L_0</M> is semisimple and we choose
a set of canonical generators of <M>L_0</M>, denoted <M>x_i</M>, <M>y_i</M>,
<M>h_i</M>, for <M>i=1,\ldots,s</M>.  Moreover, <M>L_1</M> is an 
<M>L_0</M>-module. Let <M>x_0</M> be the lowest weight vector in <M>L_1</M>.
(If <M>d=1</M> then <M>x_0</M> will be the lowest (negative) root vector.)
Let <M>\alpha_i</M> for <M>i=0,\ldots,s</M> be the roots corresponding
to <M>x_i</M>,
with respect to the subalgebra spanned by the <M>h_i</M>. Let <M>C</M> be
the Cartan matrix of these roots. The rows of <M>C</M>
are linearly dependent. The Dynkin diagram of <M>C</M> is labeled with
integers <M>a_i</M> with greatest common divisor 1, that form the coefficients 
of a linear dependency of the rows of <M>C</M>. Furthermore, the <M>x_i</M>
generate <M>L</M> and the automorphism <M>f</M> is described by
<M>f(x_i) = v^{s_i} x_i </M>, where the non-negative integers <M>s_i</M>
have greatest common divisor 1, and are such that <M>m=d\sum a_i s_i</M>
is the order of <M>f</M>, and where <M>v</M> is a primitive
<M>m</M>-th order root of unity. Now the Kac diagram of the
automorphism <M>f</M> is the Dynkin diagram of <M>C</M>, labelled with
the labels <M>s_i</M>.


<Section> <Heading> The functions </Heading>


<ManSection>
   <Oper Name="FiniteOrderInnerAutomorphisms"  Arg="type, rank, m" 
         Comm="string, integer and integer"/>
   <Description>

Let <M>L</M> be the simple Lie algebra of type <A>type</A> and rank
<A>rank</A>. The function returns representatives of the conjugacy classes
of inner automorphisms of <M>L</M> of order <A>m</A>. As noted also in the
introduction to this chapter, this function constructs the Lie algebra
as well as the automorphisms (and the Lie algebra is accessible through the
source of these automorphisms). The reason for this is that depending on the
order of the automorphisms, the base field needs certain roots of unity.


<Example>
gap> f:= FiniteOrderInnerAutomorphisms("E",6,3);
[ [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3)^2)*v.1, v.2, 
      v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
    [ v.72, (E(3))*v.1, (E(3))*v.2, v.3, v.4, v.5, v.6 ], 
  [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, v.1, (E(3))*v.2, 
      v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
    [ v.72, v.1, v.2, v.3, (E(3))*v.4, v.5, v.6 ], 
  [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3))*v.1, v.2, 
      v.3, v.4, v.5, (E(3))*v.6 ] ]
gap> Source(f[1]);
&lt;Lie algebra of dimension 78 over CF(3)>
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="FiniteOrderOuterAutomorphisms"  Arg="type, rank, m, d" 
         Comm="string, integer and integer and integer"/>
   <Description>

Let <M>L</M> be the simple Lie algebra of type <A>type</A> and rank
<A>rank</A>. The function returns representatives of the conjugacy classes
of outer automorphisms of <M>L</M> of order <A>m</A>, corresponding to a 
diagram automorphism of order <A>d</A>.

</Description>
</ManSection>

<ManSection>
   <Attr Name="Order"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism. This returns its order.

</Description>
</ManSection>

<ManSection>
   <Attr Name="KacDiagram"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism. This returns its Kac diagram.
This is a record with three components: <A>CM</A>, which is the Cartan
matrix of the Dynkin diagram, <A>labels</A> the integers with gcd equal
to 1 that are the coefficients of a linear dependency of the rows of
<A>CM</A>, and <A>weights</A> that are the integers <M>s_i</M> that 
define the automorphism.

<Example>
gap> f:= FiniteOrderOuterAutomorphisms( "A", 5, 4, 2 );;
gap> r:= KacDiagram( f[1] );
rec( 
  CM := [ [ 2, 0, -1, 0 ], [ 0, 2, -1, 0 ], [ -1, -1, 2, -1 ], 
      [ 0, 0, -2, 2 ] ], labels := [ 1, 1, 2, 1 ], weights := [ 1, 1, 0, 0 ] )
gap> r.labels*r.CM;      
[ 0, 0, 0, 0 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="Grading"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism of order <M>m</M>. 
This returns a list of length <M>m</M>. The <M>i</M>-th element contains
a basis of the eigenspace of <A>f</A> with eigenvalue <M>v^i</M>,
where <M>v</M> is a primitive <M>m</M>-th root of unity (i.e., <A>v=E(m)</A>).

</Description>
</ManSection>


<ManSection>
   <Oper Name="NilpotentOrbitsOfThetaRepresentation"  Arg="f" 
         Comm="automorphism"/>
   <Oper Name="NilpotentOrbitsOfThetaRepresentation"  Arg="L, d" 
         Comm="Lie algebra and grading diagram"
         Label="NilpotentOrbitsOfThetaRepresentationLieAlg"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>. Then <A>f</A> defines a grading on
<M>L</M>. Let the homogeneous components of this grading be denoted
<M>L_i</M> for <M>i=0,...,m-1</M>. Let <M>G_0</M> be the group corresponding
to <M>L_0</M> (i.e., the connected subgroup of the adjoint group of
<M>L</M> with Lie algebra <M>L_0</M>). This function computes representatives
for the nilpotent orbits of <M>G_0</M> acting on <M>L_1</M>. The output is a
list of triples. Each triple is an <M>sl_2</M>-triple <M>(y,h,x)</M>,
with <M>h\in L_0</M>, <M>x\in L_1</M> (the representative of the orbit),
and <M>y\in L_{m-1}</M>. The element <M>h</M> also lies in the dominant
Weyl chamber of a Cartan subalgebra of <M>L_0</M>. Finally we note that
all elements lie in <A>Source( f )</A>. <P/>
It is possible to add an extra optional argument: <A>method:= "Carrier"</A>,
or <A>method:= "WeylOrbit"</A>. Then a method based on finding carrier
algebras (respectively, computing orbits under the Weyl group) is chosen.
If no optional argument is chosen, then the system will make its own choice.
(In the case of outer automorphisms, currently the only available 
method is the one based on orbits of the Weyl group.) The method based
on carrier algebras tends to work better for the higher order automorphisms.
<P/>
This function prints some information on what it is doing to the info
class <A>InfoSLA</A>. In order to suppress these messages one can 
do <A>SetInfoLevel( InfoSLA, 1 );</A>.
<P/>
In the two-argument version, the first argument <A>L</A> has to be a 
semisimple Lie algebra, and the second argument <A>d</A> a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works the same in this case
as in the one-argument version.


<Example>
gap> # reset random state to ensure the output of this example match
gap> Reset(GlobalMersenneTwister, 1);;
gap> f:= FiniteOrderInnerAutomorphisms( "D", 5, 3 );;   
gap> s:= NilpotentOrbitsOfThetaRepresentation( f[2] : method:= "Carrier" );;
#I  Selected carrier algebra method.
#I  Constructed 123 root bases of possible flat subalgebras, now checking them...
#I  Obtained 30 Cartan elements, weeding out equivalent copies...
gap> Length(s);
10
gap> s[4];
[ v.14+v.15+v.38, (-2)*v.41+(-1)*v.42, v.18+v.34+v.35 ]
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> NilpotentOrbitsOfThetaRepresentation( L, [0,1,0,0,0,0] );
#I  Selected Weyl orbit method.
#I  Constructed a Weyl transversal of 72 elements.
#I  Obtained 5 Cartan elements, weeding out equivalent copies...
[ [ v.65+v.66+v.67, (2)*v.73+(3)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
      v.29+v.30+v.31 ], 
  [ (2)*v.55+(2)*v.66, (2)*v.73+(4)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
      v.19+v.30 ],
  [ v.66+v.70, (2)*v.73+(2)*v.74+(3)*v.75+(4)*v.76+(3)*v.77+(2)*v.78, 
      v.30+v.34 ], [ v.71, v.73+v.74+(2)*v.75+(3)*v.76+(2)*v.77+v.78, v.35 ] ]
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="ClosureDiagram"  Arg="L, f, s" 
         Comm="Lie algebra, automorphism, list of sl2-triples"/>
   <Oper Name="ClosureDiagram"  Arg="L, d, s" 
         Comm="Lie algebra, grading diagram, list of sl2-triples"
         Label="ClosureDiagramGrading"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>, and <A>s</A> a list of 
<M>sl_2</M>-triples <M>(y,h,x)</M>, with <M>h\in L_0</M>, <M>x\in L_1</M>
(for instance as computed by the previous function), corresponding to nilpotent
orbits in <M>L_1</M>.
<P/>
This function computes the Hasse diagram of the closures of
the nilpotent orbits. The output is a record with two components:
<A>diag</A> (which is a list of 2-tuples; a tuple <A>[ i, j ]</A> means
that orbit number <A>i</A> is contained in the closure of orbit number
<A>j</A>), and <A>sl2</A> (the same list of <M>sl_2</M>-triples, but sorted
according to decreasing dimension, i.e., the highest dimensional orbit
comes first). The numbering used in the tuples in <A>diag</A> corresponds
to the order in which the orbits appear in the component <A>sl2</A>.
<P/>
During the execution of the program a message is printed. This message 
either states that all inclusions have been proved, or lists a number of
possible inclusions, for which it could not be proved with absolute certainty
that these do not occur. This is due to the randomised nature of the algorithm:
if the algorithm finds an inclusion, then this inclusion is certain.
However, sometimes a non-inclusion can only be estabished by random methods,
which means that it is possible that there is an inclusion without the
program finding it. (This however, is very unlikely, and in practice almost
never happens.) Now showing that a non-inclusion really is a non-inclusion
can be done by computing the ranks of certain matrices with polynomial entries.
In principle &GAP; can do this; however, the system certainly is not very strong
at it. Therefore, as optional argument a filename can be given, by
<A>filenm:= "file.m"</A>. If this argument
is present the program prints a Magma script in the file, which can be loaded
directly into the computer algebra system Magma. If the output is always true, 
then all non-inclusions are proved. If there are non non-inclusions to be 
proved, then the file is not written.
<P/>
In the second version, the second argument <A>d</A> is a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works in the same way.
<P/>
We note that the adjoint representation can be obtained by giving a <A>d</A>
that eintirely consists of zeros.


<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "E", 8, 8 );;  
gap> h:= f[8];;
gap> sl2:= NilpotentOrbitsOfThetaRepresentation(h);;  
#I  Selected carrier algebra method.
#I  Constructed 2782 root bases of possible flat subalgebras, now checking them...
#I  Obtained 58 Cartan elements, weeding out equivalent copies...
gap> Length(sl2);
27
gap> L:= Source(h);;                    
gap> r:= ClosureDiagram( L, h, sl2 );;  
#I  All (non-) inclusions proved!
gap> r.diag;
[ [ 2, 1 ], [ 3, 1 ], [ 4, 2 ], [ 4, 3 ], [ 5, 1 ], [ 6, 5 ], [ 7, 2 ], 
  [ 7, 5 ], [ 8, 4 ], [ 9, 4 ], [ 9, 7 ], [ 10, 6 ], [ 10, 7 ], [ 11, 3 ], 
  [ 11, 6 ], [ 12, 7 ], [ 13, 9 ], [ 13, 10 ], [ 13, 11 ], [ 14, 9 ], 
  [ 14, 12 ], [ 15, 8 ], [ 15, 9 ], [ 16, 6 ], [ 17, 10 ], [ 17, 12 ], 
  [ 17, 16 ], [ 18, 13 ], [ 18, 16 ], [ 19, 13 ], [ 19, 15 ], [ 20, 11 ], 
  [ 20, 16 ], [ 21, 14 ], [ 21, 17 ], [ 21, 18 ], [ 22, 14 ], [ 22, 15 ], 
  [ 23, 18 ], [ 23, 20 ], [ 24, 18 ], [ 24, 19 ], [ 25, 21 ], [ 25, 22 ], 
  [ 25, 24 ], [ 26, 23 ], [ 26, 24 ], [ 27, 21 ], [ 27, 23 ] ]
gap> # Now we do the adjoint representation of the Lie algebra of type F4:
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> o:= NilpotentOrbits(L);;
gap> sl2:= List( o, SL2Triple );;
gap> r:= ClosureDiagram( L, [0,0,0,0], sl2 );;      
#I  All (non-) inclusions proved!
gap> r.diag;
[ [ 2, 1 ], [ 3, 2 ], [ 4, 3 ], [ 5, 3 ], [ 6, 4 ], [ 6, 5 ], [ 7, 6 ], 
  [ 8, 7 ], [ 9, 7 ], [ 10, 8 ], [ 10, 9 ], [ 11, 8 ], [ 12, 10 ], 
  [ 13, 11 ], [ 13, 12 ], [ 14, 13 ], [ 15, 14 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CarrierAlgebra"  Arg="L, f, e" 
         Comm="Lie algebra, automorphism, element of L"/>
   <Oper Name="CarrierAlgebra"  Arg="L, d, e" 
         Comm="Lie algebra, grading diagram, element of L"
         Label="CarrierAlgebraGrading"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>, and <A>e</A> a nilpotent element
of <M>L_1</M>. This function returns the carrier algebra of <A>e</A>.
This is a <M>\mathbb{Z}</M>-graded semisimple subalgebra <M>K</M> of
<M>L</M>, such that <A>e</A> lies in <M>K_1</M>. For the precise 
definition we refer to <Cite Key="vinberg2"/>, <Cite Key="vinberg3"/>.  
The output is given
in the form of a record, with three components: <A>g0</A>, a basis of
<M>K_0</M>, <A>gp</A> a list containing bases of <M>K_1</M>, <M>K_2</M> and so
on, and <A>gn</A> a list containing bases of <M>K_{-1}</M>, <M>K_{-2}</M> and
so on.
<P/>
In the second version, the second argument <A>d</A> is a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works in the same way.
<P/>


<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "F", 4, 5 );;
gap> h:= f[4];;
gap> sl2:= NilpotentOrbitsOfThetaRepresentation( h );;  
#I  Selected Weyl orbit method.
#I  Constructed a Weyl transversal of 144 elements.
#I  Constructed 621 Cartan elements to be checked.
gap> L:= Source(h);   
&lt;Lie algebra of dimension 52 over CF(5)>
gap> r:=CarrierAlgebra( L, h, sl2[1][3] );   
rec( g0 := [ v.49+(2)*v.50+(2)*v.51+(3)*v.52, v.50+(1/2)*v.51+v.52 ], 
  gn := [ [ v.24, v.33 ], [ v.21 ], [ v.15 ] ], 
  gp := [ [ v.9, v.48 ], [ v.45 ], [ v.39 ] ] )
gap> K:= Subalgebra( L, Concatenation( r.g0, Flat(r.gp), Flat(r.gn) ) );
&lt;Lie algebra over CF(5), with 10 generators>
gap> SemiSimpleType( K );
"B2"
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CartanSubspace"  Arg="f" 
         Comm="automorphism"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>. Then <A>f</A> defines a grading on
<M>L</M>. Let the homogeneous components of this grading be denoted
<M>L_i</M> for <M>i=0,...,m-1</M>. Let <M>G_0</M> be the group corresponding
to <M>L_0</M> (i.e., the connected subgroup of the adjoint group of
<M>L</M> with Lie algebra <M>L_0</M>). This function computes a maximal
subspace of <M>L_1</M> consisting of commuting semisimple elements.
(Such a subspace is called a <E>Cartan subspace</E>.)
<P/> 
Every semisimple orbit of <M>G_0</M> in <M>L_1</M> contains an element
of a fixed Cartan subspace.

<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "A", 3, 3 );;
gap> c:= CartanSubspace( f[3] ); 
&lt;vector space of dimension 1 over CF(3)>
gap> BasisVectors( Basis( c ) );
[ v.1+v.5+v.12 ]
</Example>

</Description>
</ManSection>


</Section>


</Chapter>

<Chapter> <Heading>Semisimple Subalgebras of Semisimple Lie Algebras</Heading>


This chapter contains functions for dealing with semisimple subalgebras
of semisimple Lie algebras. There are functions for computing branching rules,
for computing the regular subalgebras, and for working with the database
of semisimple subalgebras of the simple Lie algebras.

This last database contains the semisimple subalgebras of the simple
Lie algebras of ranks up to 8. The semisimple subalgebras are classified
up to linear equivalence. (Two subalgebras are called linearly equivalent 
if for every representation of the big algebra in the space <M>V</M>
the images of the subalgebras are conjugate under <M>GL(V)</M>.)




<Section> <Heading> Branching </Heading>

<ManSection>
   <Oper Name="ProjectionMatrix"  Arg="L, K" 
         Comm="two Lie algebras"/>
   <Description>

Here <A>L</A> and <A>K</A> are semisimple Lie algebras with the following
properties: <A>K</A> is contained in <A>L</A>,
the Cartan subalgebra of <A>L</A>, as returned by 
<A>CartanSubalgebra(L)</A> is split (this is automatic if <A>L</A> is
created by the built in &GAP; function) and <A>K</A> has a Cartan subalgebra
that is a subalgebra of the Cartan subalgebra of <A>L</A>. We note that
the function checks only the last property. The function returns a matrix
<A>P</A> such that if <A>u</A> is a weight of a <A>L</A>-module <M>V</M>, then
<A>P*u</A> is a weight of <A>V</A>, when considered as a <A>K</A>-module.

<Example>
gap> L:= SimpleLieAlgebra("E",7,Rationals);;                
gap> K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               
> L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;
gap> Dimension(K);
63
gap> SemiSimpleType(K);
"A7"
gap> ProjectionMatrix( L, K );
[ [ 2, 2, 3, 4, 3, 2, 1 ], [ 0, 0, -1, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 0, 0, 0 ],
  [ 0, 0, 0, 0, -1, 0, 0 ], [ 0, 0, 0, 0, 0, -1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, -1 ], [ -1, -2, -2, -3, -2, -1, 0 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
  <Oper Name="Branching"  Arg="L, K, hw"/>
  <Oper Name="Branching"  Arg="L, K, cc, hw" Label="BranchingToral"/>
   <Description>

Here <A>L</A> and <A>K</A> are as in the previous function, and <A>hw</A> is
the highest weight of an irreducible <A>L</A>-module. This function computes
the splitting of the module when seen as a <A>K</A>-module. Returned is a 
list of two lists: the first list contains the highest weights of the 
modules involved, the second list contains their multiplicities.

In the second form the subalgebra is reductive rather than semisimple.
Here <A>K</A> is again a semisimple subalgebra, and <A>cc</A> is a list of
toral elements centralizing <A>K</A>. These toral elements must lie in the
given Cartan subalgebra of <A>L</A>. The reductive subalgebra is the direct
sum of <A>K</A> and the subalgebra spanned by the elements of <A>cc</A>.
The output is the same as in the first
form. However, the last <M>t</M> coordinates of the weights give the
eigenvalues of the toral elements in <A>cc</A> on the irreducible modules.


<Example>
gap> L:= SimpleLieAlgebra("E",7,Rationals);;                
gap> K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               
> L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;
gap> Branching( L, K, [1,0,0,0,0,0,1] );
[ [ [ 1, 1, 0, 0, 0, 0, 1 ], [ 1, 1, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1, 0, 1 ],
      [ 0, 0, 1, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 0, 0 ], 
      [ 0, 1, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0, 0, 0, 0 ] ], [ 1, 1, 1, 1, 1, 1, 1, 1 ] ]
gap> L:= SimpleLieAlgebra("E",7,Rationals);;
gap> r:= RegularSemisimpleSubalgebras(L);;
gap> K:= Filtered( r, M -> SemiSimpleType(M)="E6" )[1];
&lt;Lie algebra of dimension 78 over Rationals>
gap> cc:= BasisVectors( Basis( LieCentralizer( L, K ) ) );
[ v.127+(3/2)*v.128+(2)*v.129+(3)*v.130+(5/2)*v.131+(2)*v.132+(3/2)*v.133 ]
gap> Branching( L, K, cc, [1,0,0,0,0,0,1] );
[ [ [ 0, 0, 0, 0, 0, 2, -1/2 ], [ 1, 1, 0, 0, 0, 0, -1/2 ], 
      [ 0, 0, 0, 0, 1, 0, -1/2 ], [ 1, 0, 0, 0, 0, 0, 5/2 ], 
      [ 0, 1, 0, 0, 0, 1, 1/2 ], [ 2, 0, 0, 0, 0, 0, 1/2 ], 
      [ 0, 0, 1, 0, 0, 0, 1/2 ], [ 0, 0, 0, 0, 0, 1, -5/2 ], 
      [ 1, 0, 0, 0, 0, 1, -3/2 ], [ 1, 0, 0, 0, 0, 1, 3/2 ], 
      [ 0, 1, 0, 0, 0, 0, 3/2 ], [ 0, 1, 0, 0, 0, 0, -3/2 ], 
      [ 0, 0, 0, 0, 0, 0, 3/2 ], [ 0, 0, 0, 0, 0, 0, -3/2 ], 
      [ 0, 0, 0, 0, 0, 1, 1/2 ], [ 1, 0, 0, 0, 0, 0, -1/2 ] ], 
  [ 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2 ] ]      
</Example>

</Description>
</ManSection>

</Section>

<Section> <Heading> Constructing Semisimple Subalgebras </Heading>

<ManSection>
   <Attr Name="RegularSemisimpleSubalgebras"  Arg="L" 
         Comm="a Lie algebra"/>
   <Description>

Here <A>L</A> is a <E>simple</E> Lie algebra. This function returns a
list of its conjugacy classes of semisimple subalgebras (conjugacy
under the adjoint group). 



<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> K:= RegularSemisimpleSubalgebras( L );;
gap> Length(K);
19
gap> K[5];
&lt;Lie algebra of dimension 45 over Rationals>
gap> SemiSimpleType( K[5] ); 
"D5"
gap> Branching( L, K[5], [1,0,0,0,0,1] );     
[ [ [ 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 1 ], [ 1, 0, 0, 1, 0 ], 
      [ 1, 0, 0, 0, 1 ], [ 2, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0 ] ], 
  [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Func Name="SSSTypes" Arg=""/>
   <Description>

This returns a list of the types of the semisimple Lie algebras of which
the database contains the classification of the semisimple subalgebras,
up to linear equivalence. (The three letters S stand for SemiSimple 
Subalgebras.)

</Description>
</ManSection>


<ManSection>
   <Oper Name="LieAlgebraAndSubalgebras" Arg="type"/>
   <Description>

Here <A>type</A> is a string describing the type of a semisimple Lie
algebra. A simple type is a capital letter (A, B, C, D, E, F, or G) followed
by a positive integer. Example: <A>"D5"</A>. In general a type is a sequence
of simple types separated by spaces. Example: <A>"A2 C3 E6"</A>.

This function is appliccable if each simple type that occurs in <A>type</A>
has rank less than or equal to 8.

In that case a record is returned with two components: <A>liealg</A>, which
is a semisimple Lie algebra of type <A>type</A>, and <A>subalgs</A> which
is the list of its semisimple subalgebras up to linear equivalence.

If <A>type</A> is a simple type then the list will be simply fetched from
the database. Otherwise a computation will be triggered, and afterwards the
database will be bigger. (One can check this with a call to <A>SSSTypes()</A>).
Also we remark that for non-simple types of not so small rank this computation
can be difficult.

</Description>
</ManSection>

<ManSection>
   <Oper Name="InclusionsGraph" Arg="type"/>
   <Description>

Here <A>type</A> is a string describing the type of a semisimple Lie
algebra. This is the same as in the previous function.

This function returns a list containing the edges of the inclusion graph
of the semisimple subalgebras returned by the previous function. An edge
is represented by a list of two integers. If the edge <A>[ i, j ]</A> occurs,
then this means that the subalgebra on position <A>j</A> in the list is
linearly equivalent to a subalgebra of the subalgebra in position <A>i</A>.

Only the maximal subalgebras are considered; so if we have edges <A>[ i, j ]</A>
and <A>[ j, k ]</A> then there will be no edge <A>[ i, k ]</A>. (Otherwise 
this list can become huge.)

Edges of the form <A>[ 0, j ]</A> express that the subalgebra on position
<A>j</A> is a maximal semisimple subalgebra of the Lie algebra of type 
<A>type</A>.

<Example>
# Semisimple subalgebras of the Lie algebra of type D4:
gap> s:= LieAlgebraAndSubalgebras( "D4" );;
gap> L:= s.liealg;
&lt;Lie algebra of dimension 28 over CF(3)>
gap> sub:= s.subalgs;;
gap> Length(sub);
44
gap> g:= InclusionsGraph( "D4" );;
gap> g[1];
[ 12, 1 ]

# Find the maximal semisimple subalgebras:
gap> m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );
[ 13, 35, 36, 37, 41, 42, 43, 44 ]
gap> List( sub{i}, SemiSimpleType );                
[ "A2", "A1 B2", "A1 B2", "A1 B2", "B3", "B3", "B3", "A1 A1 A1 A1" ]

# We see that the subalgebras on positions 35 and 36 are isomorphic;
# however they are not linearly equivalent:
gap> Branching( L, sub[35], [0,0,1,0] );
[ [ [ 1, 0, 1 ] ], [ 1 ] ]
gap> Branching( L, sub[36], [0,0,1,0] );
[ [ [ 0, 1, 0 ], [ 2, 0, 0 ] ], [ 1, 1 ] ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SubalgebrasInclusion" Arg="L, K1, K2"/>
   <Description>

Here <A>K1</A>, <A>K2</A>, are two subalgebras of the semisimple Lie algebra
<A>L</A>, constructed using the database. If <A>K2</A> 
contains a subalgebra that is linearly equivalent to <A>K1</A> then
such a subalgebra is returned. Otherwise the result is <A>fail</A>.


<Example>
gap> s:= LieAlgebraAndSubalgebras( "C3" );;
gap> g:= InclusionsGraph( "C3" );
[ [ 10, 1 ], [ 11, 1 ], [ 12, 1 ], [ 8, 2 ], [ 10, 2 ], [ 11, 2 ], [ 11, 3 ], 
  [ 13, 3 ], [ 8, 4 ], [ 13, 4 ], [ 9, 5 ], [ 12, 5 ], [ 12, 6 ], [ 13, 6 ], 
  [ 0, 7 ], [ 0, 8 ], [ 15, 9 ], [ 9, 10 ], [ 14, 10 ], [ 14, 11 ], 
  [ 15, 12 ], [ 0, 13 ], [ 15, 14 ], [ 0, 15 ] ]
gap> # there are the edges [ 14, 10] and [ 10, 2 ]; hence a conjugate of the
gap> # second algebra is contained in the 14-th.
gap> L:= s.liealg;
&lt;Lie algebra of dimension 21 over Rationals>
gap> sub:= s.subalgs;;
gap> K:=SubalgebrasInclusion( L, sub[2], sub[14] );
&lt;Lie algebra of dimension 3 over Rationals>
gap> Basis(K)[1] in sub[14];
true
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DynkinIndex" Arg="K, L"/>
   <Description>

Here <A>K</A> is a semisimple subalgebra of the <E>simple</E> Lie algebra
<A>L</A>. This function returns a list of integers, containing the Dynkin
indices of the simple components of <A>K</A>. If the input Lie algebra
<A>L</A> is not simple, then still a list of rationals is returned, but they
may have no meaning.

The Dynkin index is defined as follows. Consider a simple component
in <A>K</A> and let <M>h</M> be the coroot of the shortest root of <A>K</A>. 
Let <M>k</M> denote the Killing form of <A>L</A>, normalised so that
the coroot of the shortest root of <A>L</A> has squared length 2. 
Then the Dynkin index is <M>k(h,h)/2</M>.

<Example>
gap> s:= LieAlgebraAndSubalgebras( "C7" );;
gap> g:= InclusionsGraph( "C7" );;
gap> m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );
[ 63, 498, 665, 804, 819, 821, 822 ]
gap> L:= s.liealg;
&lt;Lie algebra of dimension 105 over Rationals>
gap> sub:= s.subalgs;;
gap> List( sub{i}, SemiSimpleType );   
[ "A1", "C3", "A1 B3", "A6", "C3 C4", "B2 C5", "A1 C6" ]
gap> DynkinIndex( sub[665], L );   
[ 7, 4 ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="AreLinearlyEquivalentSubalgebras" Arg="L, K1, K2"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra, and <A>K1</A>, <A>K2</A> are
subalgebras. It is assumed that the Cartan subalgebras (as returned by
<A>CartanSubalgebra</A>) of <A>K1</A>, <A>K2</A> are contained in the
Cartan subalgebra of <A>L</A> (otherwise <A>fail</A> is returned).
This function returns <A>true</A> if <A>K1</A>, <A>K2</A> are linearly 
equivalent, <A>false </A> otherwise.



<Example>
# Lets find the subalgebras in the database for C5 that are linearly
# equivalent to regular subalgebras:
gap> s:= LieAlgebraAndSubalgebras("C5");; L:= s.liealg; sub:= s.subalgs;;
&lt;Lie algebra of dimension 55 over Rationals>
gap> reg:= RegularSemisimpleSubalgebras( L );;
gap> posn:= [];;
gap> for K in reg do  
> Add(posn,PositionProperty(sub,M -> AreLinearlyEquivalentSubalgebras(L,M,K)));
> od;
gap> posn;
[ 2, 24, 93, 111, 105, 82, 106, 81, 41, 109, 70, 85, 29, 112, 94, 25, 1, 118, 
  100, 102, 64, 108, 84, 28, 117, 107, 116, 96, 101, 63, 115, 114, 95, 113 ]
</Example>


</Description>
</ManSection>

<ManSection>

   <Oper Name="MakeDatabaseEntry" Arg="r"/>
   <Oper Name="AddToDatabase" Arg="d"/>

   <Description>

These are functions that help to save a computed list of subalgebras of a 
semisimple Lie algebra in a file, and in a new session, read it again.

In the first function <A>r</A> is a record as produced by 
<Ref Oper="LieAlgebraAndSubalgebras"/>. It returns a record that can be saved
in a file. (It is not advisable to print it on the screen.)

In the second function <A>d</A> is a record that is output by
<Ref Oper="MakeDatabaseEntry"/>. This function adds this entry to the database.
<P/>
We give two examples; in the first one we create a new database entry,
and save it to a file. In the second example we read it and add it to the
database.

<Example>
gap> r:= LieAlgebraAndSubalgebras( "A2 B2" );;
gap> d:= MakeDatabaseEntry( r );;
gap> PrintTo( "A2B2", "d:= ",d,";\n");
</Example>

<Log>
gap> Read("A2B2");
gap> AddToDatabase( d );
gap> SSSTypes();
[ "A1", "A2", "B2", "G2", "A3", "B3", "C3", "A4", "B4", "C4", "D4", "F4", 
  "A5", "B5", "C5", "D5", "A6", "B6", "C6", "D6", "E6", "A7", "B7", "C7", 
  "D7", "E7", "A8", "B8", "C8", "D8", "E8", "A2 B2" ]
</Log>


</Description>
</ManSection>

<ManSection>
   <Oper Name="ClosedSubsets" Arg="R"/>
   <Description>

Here <A>R</A> is a root system. A subset <M>S</M> of the roots of <A>R</A> is
said to be closed if for all <M>a,b\in S</M> we have that <M>a+b</M> lies in
<M>S</M> whenever <M>a+b</M> is a root. This function computes the list of the
closed subsets of <A>R</A> up to conjugacy by the Weyl group. In other words,
each closed subset of <A>R</A> is conjugate under the Weyl group to exactly
one element of the output of this function.

The output is a list of which each element is a list of roots. A root in
such a list, or its negative, lies in the attribute
<A>PositiveRootsNF( R )</A>.


<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);;
gap> Length(c);
4844
gap> c[1005];
[ [ 1, 1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 2, 0 ], [ 0, 1, 1, 1 ], 
  [ 1, 1, 1, 1 ], [ 1, 2, 2, 0 ], [ 1, 1, 2, 1 ], [ 0, 1, 2, 2 ], 
  [ 1, 1, 2, 2 ], [ 1, 2, 3, 1 ], [ 1, 2, 2, 2 ], [ 1, 2, 3, 2 ], 
  [ 1, 2, 4, 2 ], [ 1, 3, 4, 2 ], [ 2, 3, 4, 2 ], [ 0, -1, -2, 0 ] ]
</Example>


</Description>
</ManSection>


<ManSection>
   <Oper Name="DecompositionOfClosedSet" Arg="c"/>
   <Description>

Here <A>c</A> is a closed set of roots of some root system. We have that 
<A>c</A> is the disjoint union of its symmetric part (consisting of all
roots <M>a</M> in <A>c</A> such that <M>-a</M> also lies in <A>c</A>) and
its special part (consisting of all
roots <M>a</M> in <A>c</A> such that <M>-a</M> does not lie in <A>c</A>).
This function returns a list of two entries. The first is the symmetric part of
<A>c</A>, the second is the special part of <A>c</A>.

<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);;
gap> DecompositionOfClosedSet( c[1005] );
[ [ [ 0, 1, 2, 0 ], [ 0, -1, -2, 0 ] ], 
  [ [ 1, 1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 1, 1, 1 ], 
      [ 1, 2, 2, 0 ], [ 1, 1, 2, 1 ], [ 0, 1, 2, 2 ], [ 1, 1, 2, 2 ], 
      [ 1, 2, 3, 1 ], [ 1, 2, 2, 2 ], [ 1, 2, 3, 2 ], [ 1, 2, 4, 2 ], 
      [ 1, 3, 4, 2 ], [ 2, 3, 4, 2 ] ] ]
</Example>


</Description>
</ManSection>


<ManSection>
   <Oper Name="IsSpecialClosedSet" Arg="c"/>
   <Description>

Here <A>c</A> is a closed set of roots of some root system. This function
returns <A>true</A> is <A>c</A> is special (that is, for all <M>a</M> in
<A>c</A> we have that <M>-a</M> does not lie in <A>c</A>), otherwise it
returns <A>false</A>.


<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);;
gap> IsSpecialClosedSet( c[1005] );
false
gap> IsSpecialClosedSet( c[1006] );
true
gap> Length( Filtered( c, IsSpecialClosedSet ) );
3579
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="LieAlgebraOfClosedSet" Arg="L, c"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra and 
<A>c</A> is a closed set of roots of its root system.
This function returns the subalgebra of <A>L</A> spanned a the Cartan
subalgebra of <A>L</A> (the one relative to which the root system is
taken) along with the root vectors corresponding to the roots in
<A>c</A>.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);
&lt;Lie algebra of dimension 52 over Rationals>
gap> R:= RootSystem( L );
&lt;root system of rank 4>
gap> c:= ClosedSubsets(R);; 
gap> c[1005];
[ [ 1, 0, 1, 0 ], [ 0, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 2, 1 ], 
  [ 1, 1, 1, 1 ], [ 1, 1, 2, 1 ], [ 2, 0, 2, 1 ], [ 0, 1, 2, 2 ], 
  [ 2, 1, 2, 1 ], [ 1, 1, 3, 2 ], [ 2, 1, 2, 2 ], [ 2, 1, 3, 2 ], 
  [ 2, 1, 4, 2 ], [ 2, 1, 4, 3 ], [ 2, 2, 4, 3 ], [ 0, 0, -2, -1 ] ]
gap> K:= SubalgebraOfClosedSet( L, c[1005] );
&lt;Lie algebra of dimension 20 over Rationals>
gap> LeviMalcevDecomposition(K);
[ &lt;Lie algebra of dimension 3 over Rationals>, 
  &lt;two-sided ideal in &lt;Lie algebra of dimension 20 over Rationals>, 
      (dimension 17)> ]
</Example>


</Description>
</ManSection>


</Section>
</Chapter>


</Body>

<Bibliography Databases="sla" />

<TheIndex/>


</Book>

<?xml version="1.0" encoding="utf-8"?>


<!DOCTYPE Book SYSTEM "gapdoc.dtd"
[<!ENTITY SLA "<Package>SLA</Package>">] >




<Book Name="SLA">

<#Include SYSTEM "title.xml">

<TableOfContents/>

<Body>

<Chapter> <Heading>Introduction</Heading>

This package is a collection of functions that I wrote for various 
research projects (e.g., <Cite Key="wdg08"/>, <Cite Key="gra15"/>, 
<Cite Key="elasgra"/>, <Cite Key="grasss"/>, <Cite Key="closure"/>).
The reason to collect them in a package is to
avoid them getting lost. Secondly, I believe that the functions
may be of wider interest. <P/>
Apart from this one, this manual has four chapters. The second describes
various functions that did not fit in any of the other chapters. They vary
from short utility functions to functions implementing rather 
complex algorithms. 
The remaining three chapters are all devoted to a particular area.<P/>

The third chapter contains (descriptions of) functions for computing 
with the classification of the nilpotent orbits in simple Lie algebras.
There are functions for creating the orbits and for computing representatives.
We refer to <Cite Key="colmcgov"/> for an overview of the theory of
nilpotent orbits in simple Lie algebras.
<P/>


The fourth chapter is dedicated to finite order automorphisms of the simple
Lie algebras and the
corresponding <M>\theta</M>-groups. The finite order automorphisms have
been classified by Kac, up to conjugacy in the automorphism group. 
For the background on this we refer to <Cite Key="helgason"/>.
The classification is described in terms of so-called Kac diagrams. 
The package contains a function for creating all automorphisms of a
given simple Lie algebra, of a given finite order. <P/>

The eigenspaces of an automorphism of finite order of a simple
Lie algebra form a grading of that Lie algebra. Moreover, the
0-component is a reductive subalgebra, acting on the 1-component.
The 0-component corresponds to a reductive reductive group, also acting
on the 1-component. This group (with its action) is called a 
<M>\theta</M>-group. It was introduced and studied in the 70-s by Vinberg
(<Cite Key="vinberg3"/> , <Cite Key="vinberg"/>, <Cite Key="vinberg2"/>)  
The package has a function for listing the
nilpotent orbits of this group. <P/>

The fifth chapter has functions for working with semisimple subalgebras
of semisimple Lie algebras. The package contains a database of semisimple
subalgebras of the simple subalgebras of ranks up to 8. Moreover, there
are functions for computing the semisimple subalgebras of semisimple Lie
algebras on the fly. Finally, there are some functions for computing
branching rules. <P/>
We remark that the package needs the package <Package>QuaGroup</Package>.




</Chapter>

<Chapter> <Heading>Auxiliary Functions</Heading>


This chapter contains the description of some functions 
that do not fit in any other chapter.


<Section> <Heading> Root Systems </Heading>

<ManSection>
   <Oper Name="ExtendedCartanMatrix"  Arg="R" 
         Comm="root system"/>
   <Description>

Here <A>R</A> is a root system. This function returns the extended Cartan
matrix of <A>R</A>. That is the Cartan matrix correponding to the 
lowest root (coming first), and the simple roots of <A>R</A>. <P/>
The output is a record with components <A>ECM</A> (the extended Cartan
matrix) and <A>labels</A> (the labels of the corresponding Dynkin diagram;
they are the integer coefficients of a linear dependency of the 
roots corresponding to the nodes).
<Example>
gap> R:= RootSystem("F",4);;
gap> ExtendedCartanMatrix(R);
rec( ECM := [ [ 2, -1, 0, 0, 0 ], [ -1, 2, -1, 0, 0 ], [ 0, -1, 2, -2, 0 ], 
      [ 0, 0, -1, 2, -1 ], [ 0, 0, 0, -1, 2 ] ], labels := [ 1, 2, 3, 4, 2 ] )
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CartanType"  Arg="C" 
         Comm="Cartan matrix"/>
   <Description>

Here <A>C</A> is a Cartan matrix (i.e., an integer matrix with 2-s on the  
diagonal, non-positive entries otherwise, and there exists a diagonal
integer matrix <A>D</A> such that <A>CD</A> is a positive definite 
symmetric matrix). This function returns a record with two components:
<A>types</A>, a list containing the types of the simple components of
the corresponding root system, and <A>enumeration</A>, a standard enumeration
of the vertices of the Dynkin diagram of <A>C</A>. 
So this can be used to construct isomorphisms of root systems.

<Example>
gap> C:= [[2,0,-3,0],[0,2,0,-1],[-1,0,2,0],[0,-1,0,2]];
[ [ 2, 0, -3, 0 ], [ 0, 2, 0, -1 ], [ -1, 0, 2, 0 ], [ 0, -1, 0, 2 ] ]
gap> CartanType(C);
rec( types := [ [ "G", 2 ], [ "A", 2 ] ], 
  enumeration := [ [ 3, 1 ], [ 2, 4 ] ] )
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="WeylTransversal"  Arg="R, inds" 
         Comm="Root system and list"/>
   <Oper Name="WeylTransversal"  Arg="R, roots" 
         Comm="Root system and list"/>
   <Description>

Here <A>R</A> is a root system, and <A>inds</A> a list of indices of
<E>positive</E> roots of <A>R</A> that form a set of simple roots of
a root subsystem of <A>R</A> (the system does not check this). Here an
index of a positive root is its position in the list 
<A>PositiveRootsNF( R )</A>.<P/>
This function returns a list of shortest representatives of the right
cosets of the corresponding Weyl subgroup of the Weyl group of <A>R</A>.
The elements of the Weyl group are given as reduced expressions. <P/>
In the second form <A>rts</A> is a list of roots of <A>R</A>, that form
a set of simple roots of a root subsystem of <A>R</A> (again, this is
not checked). In this form the roots so not have to be positive.
They have to be represented with respect to the basis of simple roots,
i.e., they are elements of <A>PositiveRootsNF(R)</A> or of 
<A>NegativeRootsNF(R)</A>.


<Example>
gap> R:= RootSystem("A",3);;
gap> WeylTransversal( R, [2,6] );
[ [  ], [ 1 ], [ 3 ], [ 1, 2 ], [ 1, 3 ], [ 3, 2 ] ]
gap> R:= RootSystem("E",8);;
gap> p:= PositiveRootsNF(R);;
gap> a:= WeylTransversal( R, [p[1],p[3],p[4],p[5],p[6],p[7],p[8],-p[120]] );;
gap> Length(a);
1920
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="SizeOfWeylGroup"  Arg="R" />
   <Oper Name="SizeOfWeylGroup"  Arg="type" />
   <Oper Name="SizeOfWeylGroup"  Arg="X,n" />
   <Description>

In the first from <A>R</A> is a root system. In the second
form <A>type</A> is a list of lists describing the type of a 
root system. For example: <A>[["A",3],["B",5],["G",2]]</A>. 
In the third form <A>X</A> is a letter (i.e., a string) and 
<A>n</A> a positive integer, so that <A> Xn</A> is the type of
a root system. In all cases the number of elements of the Weyl group
is returned.

<Example>
gap> R:= RootSystem( SimpleLieAlgebra("E",6,Rationals) );;
gap> SizeOfWeylGroup(R);                
51840
gap> SizeOfWeylGroup( [["E",6]] );
51840
gap> SizeOfWeylGroup( "E", 6 );   
51840
</Example>

</Description>
</ManSection>



</Section>

<Section> <Heading> Lie Algebras and Their Modules </Heading>

<ManSection>
   <Oper Name="IsomorphismOfSemisimpleLieAlgebras"  Arg="L1, L2"/>

<Description>

Here <A>L1</A> and <A>L2</A> are two semisimple Lie algebras that are
known to be isomorphic (i.e., they have the same type). This function
returns an isomorphism.

</Description>
</ManSection>

<ManSection>
   <Oper Name="AdmissibleLattice"  Arg="V"/>

<Description>

Here <A>V</A> is a <E>simple</E> module over a semisimple Lie algebra.
This function returns a basis
of <A>V</A> that spans an admissible lattice in <A>V</A>. This means
that for a root vector <M>x</M> of the acting Lie algebra the
matrix <M>exp( mx )</M> is integral, where <M>mx</M> denotes the matrix
of <M>x</M> relative to the admissible lattice.

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [2,0] );
&lt;27-dimensional left-module over &lt;Lie algebra of dimension 14 over Rationals>>
gap> B:=AdmissibleLattice(V);;
gap> x:= L.1;
v.1
gap> mx:= MatrixOfAction( B, x );;
gap> IsZero(mx^4); IsZero(mx^5);
false
true
gap> exp:=Sum( List( [0..4], i -> mx^i/Factorial(i) ) );;
gap> ForAll( Flat(exp), IsInt );
true
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DirectSumDecomposition"  Arg="V"/>

<Description>

Here <A>V</A> is a module over a semisimple Lie algebra; this function
computes a list of sub-modules such that <A>V</A> is their direct sum.

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> V:= HighestWeightModule( L, [1,0] );;
gap> W:= TensorProductOfAlgebraModules( V, V );
&lt;49-dimensional left-module over &lt;Lie algebra of dimension 14 over Rationals>>
gap> DirectSumDecomposition( W );
[ &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>>, 
  &lt;left-module over &lt;Lie algebra of dimension 14 over Rationals>> ]
gap> List( last, Dimension );
[ 14, 7, 1, 27 ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="CharacteristicsOfStrata"  Arg="L, hw"/>

<Description>

Here <A>L</A> is a semisimple Lie algebra over a field of characteristic 0.
Secondly, <A>hw</A> is a dominant weight, represented as a list of non-negative
integers (where the ordering of the fundamantal weights is given by the
Cartan matrix of the root system of <A>L</A>). Let <M>G</M> denote the 
semisimple algebraic group acting on the irreducible representation with
highest weight <A>hw</A>. Hesselink (<Cite Key="hesselink"/>)
defined a stratification of the nullcone relative to the action of <M>G</M>. 
Popov and Vinberg (<Cite Key="povin"/>) have described this
stratification in terms of characteristics, which are elements of a Cartan
subalgebra of <A>L</A>. To each characteristic there corresponds a stratum.
This function is an implementation of an algorithm due to Popov
(<Cite Key="popov"/>), for computing the characteristics of the strata. It
returns a list of two lists. The first list contains the 
characteristics. The second list contains the dimensions of the corresponding 
strata. If the highest weight <A>hw</A> defines the adjoint representation,
then the characteristics of the strata are exactly the characteristics
of the nilpotent orbits in <A>L</A>. This means the following: let <M>h</M> be
a characteristic, then there are <M>e,f</M> in <A>L</A> such that the triple
<M>h,e,f</M> satisfies the commutation relations of <M>\mathfrak{sl}_2</M>,
and the elements <M>e</M> thus obtained are the representatives of the
nilpotent <M>G</M>-orbits in <A>L</A>.
 

<Example>
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> L:= SimpleLieAlgebra("G",2,Rationals);;
gap> CharacteristicsOfStrata( L, [0,1] );
[ [ v.13+(2)*v.14, (2)*v.13+(3)*v.14, (2)*v.13+(4)*v.14, (6)*v.13+(10)*v.14 ],
  [ 6, 8, 10, 12 ] ]
</Example>


</Description>
</ManSection>


</Section>


</Chapter>


<Chapter> <Heading>Nilpotent Orbits</Heading>

This chapter contains functions for dealing with the nilpotent orbits of a
semisimple Lie algebra <M>K</M> under its adjoint group <M>G</M>. We refer
to the book by Collingwood and McGovern,  <Cite Key="colmcgov"/>
(and the references therein) for an account of the theory of nilpotent orbits.

A nilpotent orbit has two important attributes: the weighted Dynkin diagram,
and an <M>sl_2</M>-triple. The weighted Dynkin diagram is represented by a list of 
integers in {0,1,2} of length equal to the rank of the Lie algebra. The i-th 
position in this list correponds to the i-th node of the Dynkin diagram of the 
root system. The Dynkin diagram of the root system is described by the Cartan 
matrix of the root system. Now in GAP this Cartan matrix can be somewhat 
different from the more usual forms. This holds most particularly for type F4, 
where the enumeration of the simple roots is rather different from the one 
usually found. So when using the functions in this chapter one should keep this 
in mind.
<P/>
Every nilpotent orbit has an <M>sl_2</M>-triple, that is a triple <M>(y,h,x)</M> of 
elements of the simple Lie algebra with <M>[x,y]=h</M>, 
<M>[h,x]=2x</M>, <M>[h,y]=-2y</M>. The 
nilpotent orbit corresponding to this is the orbit
of the element x under the action of the adjoint group. 
<P/>
Let <M>P</M> be a parabolic subalgebra of <M>K</M>
(i.e., generated by the Cartan subalgebra of <M>K</M>,
all positive root vectors, along with the negative simple
root vectors corresponding to a given subset of the basis of simple
roots), <M>L</M> the corresponding Levi subalgebra (i.e., the reductive part of 
<M>P</M>), and <M>N</M> the nilradical of <M>P</M>. Let <M> O_L</M> be a nilpotent
orbit in <M>L</M>. There exists a 
unique nilpotent orbit <M>O_K</M> in <M>K</M> such that the intersection of 
<M>O_K</M> and <M>O_L + N</M> is dense in the latter. In this situation <M>O_K</M> is
said to be <E>induced</E> from <M>O_L</M>. Nilpotent orbits in <M>K</M> which are not 
induced are said to be <E>rigid</E>. 
<P/>
Now consider the variety of all <M>G</M>-orbits in <M>K</M> of a given dimension
<M>d</M>. The irreducible components of this variety are called the <E>sheets</E>
of <M>K</M>. Every sheet has a unique nilpotent
orbit. Moreover this nilpotent orbit is induced from an orbit <M>O_L</M>, and
<M>O_L</M> is rigid in <M>L</M>. So the sheets are parametrised by pairs 
<M>(L,O_L)</M>, where <M>L</M> is a Levi subalgebra, and <M>O_L</M> a rigid nilpotent
orbit in it. This data can conveniently be given by a <E>sheet diagram</E>:
this is the Dynkin diagram of <M>K</M>, were the nodes that do <E>not</E> correspond
to simple roots of <M>L</M> have label 2. So, leaving out the nodes with label 2, one
obtains the Dynkin diagram of <M>L</M>. The remaining labels in the sheet diagram
then correspond to the weighted Dynkin diagram of the nilpotent orbit <M>O_L</M>.
Since this orbit is rigid, its weighted Dynki diagram has labels 0 or 1. From that
it follows that one can recover <M>L</M> and <M>O_L</M> from the sheet diagram.
The <E>rank</E> of a sheet is defined as the dimension of the centre of <M>L</M>,
obviously that is equal to the number of 2's in the sheet diagram.



<Section> <Heading> The functions </Heading>

<ManSection>
   <Oper Name="NilpotentOrbit"  Arg="L, wd" 
         Comm="Lie algebra and weighted Dynkin diagram"/>
   <Description>

Here <A>L</A> is a simple Lie algebra and <A>wd</A> a weighted Dynkin
diagram (i.e., a list containing the weights of the weighted Dynkin
diagram, in the same order as the nodes of the Dynkin diagram of 
the root system of <A>L</A>; that order can be deduced from the Cartan
matrix of the same root system).
The corresponding nilpotent orbit is returned. It is the responsibility
of the user to make sure that the weighted Dynkin diagram corresponds to a 
nilpotent orbit.
<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> o:= NilpotentOrbit( L, [1,2,0,0,0,1] );
&lt;nilpotent orbit in Lie algebra of type E6>
</Example>

</Description>
</ManSection>


<ManSection>
   <Attr Name="NilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra. This function returns the
list of all nilpotent orbits of <A>L</A>. 

If <A>L</A> is simple of classical type, then the nilpotent orbits correpond
to partitions (of <M>n+1</M> for type <M>A_n</M>, of <M>2n+1</M> for type
<M>B_n</M>, of <M>2n</M> for type <M>C_n</M> and of <M>2n</M> for type
<M>D_n</M>, see <Cite Key="colmcgov"/>). If <A>L</A> is of one of these
types then the orbits returned by this function have the attribute
<A>OrbitPartition</A> set, which returns the corresponding partition.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> orbs[10];
&lt;nilpotent orbit in Lie algebra of type E6>
gap> Length(orbs);
20
gap> L:= SimpleLieAlgebra("B",4,Rationals);;
gap> orbs:= NilpotentOrbits(L);;            
gap> OrbitPartition( orbs[10] );
[ 5, 2, 2 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="WeightedDynkinDiagram"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns its weighted
Dynkin diagram.

</Description>
</ManSection>

<ManSection>
   <Meth Name="WeightedDynkinDiagram"  Arg="L, x" 
         Comm="Lie algebra and nilpotent element"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra, and <A>x</A> a nilpotent element.
This function returns the weighted Dynkin diagram of the orbit containing 
<A>x</A>. 

<Example>
gap> L:= SimpleLieAlgebra("B",3,Rationals);;
gap> WeightedDynkinDiagram( L, L.1+L.9 ); 
[ 2, 0, 0 ]
gap> L:= SimpleLieAlgebra("E",6,Rationals );;
gap> WeightedDynkinDiagram(L, L.1+L.6+L.20+2*L.32 : table:= true );
[ 0, 0, 0, 1, 0, 0 ]
gap> time;
2048
gap> WeightedDynkinDiagram(L, L.1+L.6+L.20+2*L.32 : table:= true );
[ 0, 0, 0, 1, 0, 0 ]
gap> time;
64
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="AmbientLieAlgebra"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns the Lie algebra
it lives in.

</Description>
</ManSection>

<ManSection>
   <Attr Name="SemiSimpleType"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns the type of the 
Lie algebra it lives in.

</Description>
</ManSection>


<ManSection>
   <Attr Name="SL2Triple"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns an sl_2-triple
<M>(y,h,x)</M> corresponding to <A>o</A>. For the exceptional types the 
<M>x</M> is as in the paper <Cite Key="wdg08"/>. For the classical types
the <M>x</M> is computed on the fly.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> SL2Triple( orbs[10] );
[ (4)*v.51+(3)*v.53+(3)*v.56+v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.15+v.17+v.20+v.23 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="RandomSL2Triple"  Arg="o" 
         Comm="nilpotent orbit"/>
   <Description>

Here <A>o</A> is a nilpotent orbit; this function returns a random sl_2-triple
<M>(x,h,y)</M> corresponding to <A>o</A>. This means that every call
(potentially) returns a different sl_2-triple.


<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> RandomSL2Triple( orbs[10] );
[ (3)*v.49+(3)*v.50+v.51+(4)*v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.13+v.14+v.15+v.23 ]
gap> RandomSL2Triple( orbs[10] );
[ (3)*v.50+(3)*v.53+v.54+(4)*v.57, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
    8)*v.77+(4)*v.78, v.14+v.17+v.18+v.21 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SL2Grading"  Arg="L, h" 
         Comm="Lie algebra and nuetral element of sl_2 triple"/>
   <Description>

Here <A>L</A> is a Lie algebra, and <A>h</A> is an element of it, such
that there is an sl_2 triple of which it is the Cartan element (the system
does not check that). This function returns the grading of <A>L</A> in
eigenspaces of <A>h</A>.

A list containing three lists is returned:
the first list contains bases of the components with degrees 1,2,3,... the
second list has bases of the components with degrees -1,-2,-3,..., the
last list contains a basis of the zero component.


<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> orbs:= NilpotentOrbits(L);;
gap> sl2:= RandomSL2Triple( orbs[6] );
[ v.36+(2)*v.40+(2)*v.42, (3)*v.49+(4)*v.50+(6)*v.51+(8)*v.52, v.12+v.16+v.18 
 ]
gap> SL2Grading( L, sl2[2] );
[ [ [ v.3, v.5, v.7, v.8, v.9, v.11 ], 
      [ v.10, v.12, v.13, v.14, v.15, v.16, v.17, v.18, v.20 ], 
      [ v.19, v.21 ], [ v.22, v.23, v.24 ] ], 
  [ [ v.27, v.29, v.31, v.32, v.33, v.35 ], 
      [ v.34, v.36, v.37, v.38, v.39, v.40, v.41, v.42, v.44 ], 
      [ v.43, v.45 ], [ v.46, v.47, v.48 ] ], 
  [ v.1, v.2, v.4, v.6, v.25, v.26, v.28, v.30, v.49, v.50, v.51, v.52 ] ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SL2Triple"  Arg="L, x" 
         Comm="Lie algebra and nilpotent element"/>
   <Description>

Here <A>L</A> is a simple Lie algebra, and <A>x</A> is a nilpotent 
element of it. A list of three elements is returned, forming an 
sl_2-triple, the last of which is equal to <A>x</A>.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> SL2Triple( L, L.1+L.20 );
[ v.16+v.25, v.49, v.1+v.20 ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Attr Name="InducedNilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a simple Lie algebra. This function returns the
list of all induced nilpotent orbits of <A>L</A>.  
An induced orbit is given by a record containing
two fields: <A>sheetdiag</A>, which is a diagram describing the Levi subalgebra and the 
rigid nilpotent orbit in it from which the nilpotent orbit is induced, and <A>norbit</A>,
which is the induced nilpotent orbit in <A>L</A>. 

The sheet diagram is a labeled Dynkin diagram, and the labels are 0, 1 or 2. 
If we take the Dynkin diagram and erase the nodes which have label 2 then we obtain
the Dynkin diagram of the Levi subalgebra. Moreover, the labels 0 and 1 on that diagram 
give the rigid nilpotent orbit in the Levi subalgebra. From this pair the nilpotent
orbit <A>norbit</A> is induced.

It may happen that the same nilpotent orbit is induced from more pairs consisting of a 
Levi subalgebra and a rigid nilpotent orbit in it. In that case the same nilpotent
orbit appears more than once in the list, each time with a different sheet diagram 
attached.

This function works for the Lie algebras of exceptional type and for the Lie 
algebras of type <M>A</M> regardless of the rank. It works for the Lie algebras 
of the other types up to rank 10.

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> s:= InducedNilpotentOrbits(L);;
gap> s[19];
rec( norbit := &lt;nilpotent orbit in Lie algebra of type E6>, 
sheetdiag := [ 2, 0, 0, 1, 0, 2 ] )
gap> WeightedDynkinDiagram( s[19].norbit );
[ 0, 0, 0, 2, 0, 0 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="RigidNilpotentOrbits"  Arg="L" 
         Comm="Lie algebra"/>
   <Description>

Here <A>L</A> is a simple Lie algebra. This function returns the
list of all rigid nilpotent orbits of <A>L</A>, <E>except</E> the zero orbit
(which is always rigid).

<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> RigidNilpotentOrbits(L);
[ &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6>, 
  &lt;nilpotent orbit in Lie algebra of type E6> ]
gap> List( last, WeightedDynkinDiagram );
[ [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 1 ] ]
</Example>

</Description>
</ManSection>


</Section>

</Chapter>

<Chapter> <Heading>Finite Order Automorphisms and <M>\theta</M>-Groups</Heading>

This chapter contains functions for creating and working with
finite order automorphisms of simple Lie algebras (or, more precisely,
representatives of the conjugacy classes of such automorphisms). <P/>

NB: such automorphisms are not created for a given Lie algebra, but
the Lie algebra is constructed at the same time as the automorphism.
This because the base field may need extending (it needs enough roots of 
unity). <P/>

As noted above the functions give representatives of the conjugacy
classes, in the automorphism group of the underlying Lie algebra,
of finite order automorphisms. Such conjugacy classes are classified in
terms of Kac diagrams. Roughly, this works as follows. A finite order
automorphism <M>f</M> 
corresponds to a diagram automorphism of order <M>d=1,2,3</M>.
The inner automorphisms correspond to a diagram automorphism of 
order 1, the outer automorphisms to a diagram automorphism of
order 2 or 3. Let <M>L_0, L_1</M> denote the eigenspaces of the underlying
Lie algebra <M>L</M>, with respect to the diagram automorphism, respectively
corresponding to the eigenvalues 1 and <M>w</M> (where <M>w</M> is a 
primitive <M>d</M>-th root of unity). (In case of <M>d=1</M>, we have
<M>L_0=L</M>, <M>L_1=0</M>.) Then <M>L_0</M> is semisimple and we choose
a set of canonical generators of <M>L_0</M>, denoted <M>x_i</M>, <M>y_i</M>,
<M>h_i</M>, for <M>i=1,\ldots,s</M>.  Moreover, <M>L_1</M> is an 
<M>L_0</M>-module. Let <M>x_0</M> be the lowest weight vector in <M>L_1</M>.
(If <M>d=1</M> then <M>x_0</M> will be the lowest (negative) root vector.)
Let <M>\alpha_i</M> for <M>i=0,\ldots,s</M> be the roots corresponding
to <M>x_i</M>,
with respect to the subalgebra spanned by the <M>h_i</M>. Let <M>C</M> be
the Cartan matrix of these roots. The rows of <M>C</M>
are linearly dependent. The Dynkin diagram of <M>C</M> is labeled with
integers <M>a_i</M> with greatest common divisor 1, that form the coefficients 
of a linear dependency of the rows of <M>C</M>. Furthermore, the <M>x_i</M>
generate <M>L</M> and the automorphism <M>f</M> is described by
<M>f(x_i) = v^{s_i} x_i </M>, where the non-negative integers <M>s_i</M>
have greatest common divisor 1, and are such that <M>m=d\sum a_i s_i</M>
is the order of <M>f</M>, and where <M>v</M> is a primitive
<M>m</M>-th order root of unity. Now the Kac diagram of the
automorphism <M>f</M> is the Dynkin diagram of <M>C</M>, labelled with
the labels <M>s_i</M>.


<Section> <Heading> The functions </Heading>


<ManSection>
   <Oper Name="FiniteOrderInnerAutomorphisms"  Arg="type, rank, m" 
         Comm="string, integer and integer"/>
   <Description>

Let <M>L</M> be the simple Lie algebra of type <A>type</A> and rank
<A>rank</A>. The function returns representatives of the conjugacy classes
of inner automorphisms of <M>L</M> of order <A>m</A>. As noted also in the
introduction to this chapter, this function constructs the Lie algebra
as well as the automorphisms (and the Lie algebra is accessible through the
source of these automorphisms). The reason for this is that depending on the
order of the automorphisms, the base field needs certain roots of unity.


<Example>
gap> f:= FiniteOrderInnerAutomorphisms("E",6,3);
[ [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3)^2)*v.1, v.2, 
      v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
    [ v.72, (E(3))*v.1, (E(3))*v.2, v.3, v.4, v.5, v.6 ], 
  [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, v.1, (E(3))*v.2, 
      v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
    [ v.72, v.1, v.2, v.3, (E(3))*v.4, v.5, v.6 ], 
  [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3))*v.1, v.2, 
      v.3, v.4, v.5, (E(3))*v.6 ] ]
gap> Source(f[1]);
&lt;Lie algebra of dimension 78 over CF(3)>
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="FiniteOrderOuterAutomorphisms"  Arg="type, rank, m, d" 
         Comm="string, integer and integer and integer"/>
   <Description>

Let <M>L</M> be the simple Lie algebra of type <A>type</A> and rank
<A>rank</A>. The function returns representatives of the conjugacy classes
of outer automorphisms of <M>L</M> of order <A>m</A>, corresponding to a 
diagram automorphism of order <A>d</A>.

</Description>
</ManSection>

<ManSection>
   <Attr Name="Order"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism. This returns its order.

</Description>
</ManSection>

<ManSection>
   <Attr Name="KacDiagram"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism. This returns its Kac diagram.
This is a record with three components: <A>CM</A>, which is the Cartan
matrix of the Dynkin diagram, <A>labels</A> the integers with gcd equal
to 1 that are the coefficients of a linear dependency of the rows of
<A>CM</A>, and <A>weights</A> that are the integers <M>s_i</M> that 
define the automorphism.

<Example>
gap> f:= FiniteOrderOuterAutomorphisms( "A", 5, 4, 2 );;
gap> r:= KacDiagram( f[1] );
rec( 
  CM := [ [ 2, 0, -1, 0 ], [ 0, 2, -1, 0 ], [ -1, -1, 2, -1 ], [ 0, 0, -2, 2 
         ] ], labels := [ 1, 1, 2, 1 ], weights := [ 1, 1, 0, 0 ] )
gap> r.labels*r.CM;      
[ 0, 0, 0, 0 ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Attr Name="Grading"  Arg="f" 
         Comm="finite order automorphism"/>
   <Description>

Here <A>f</A> is a finite order automorphism of order <M>m</M>. 
This returns a list of length <M>m</M>. The <M>i</M>-th element contains
a basis of the eigenspace of <A>f</A> with eigenvalue <M>v^i</M>,
where <M>v</M> is a primitive <M>m</M>-th root of unity (i.e., <A>v=E(m)</A>).

</Description>
</ManSection>


<ManSection>
   <Oper Name="NilpotentOrbitsOfThetaRepresentation"  Arg="f" 
         Comm="automorphism"/>
   <Oper Name="NilpotentOrbitsOfThetaRepresentation"  Arg="L, d" 
         Comm="Lie algebra and grading diagram"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>. Then <A>f</A> defines a grading on
<M>L</M>. Let the homogeneous components of this grading be denoted
<M>L_i</M> for <M>i=0,...,m-1</M>. Let <M>G_0</M> be the group corresponding
to <M>L_0</M> (i.e., the connected subgroup of the adjoint group of
<M>L</M> with Lie algebra <M>L_0</M>). This function computes representatives
for the nilpotent orbits of <M>G_0</M> acting on <M>L_1</M>. The output is a
list of triples. Each triple is an <M>sl_2</M>-triple <M>(y,h,x)</M>,
with <M>h\in L_0</M>, <M>x\in L_1</M> (the representative of the orbit),
and <M>y\in L_{m-1}</M>. The element <M>h</M> also lies in the dominant
Weyl chamber of a Cartan subalgebra of <M>L_0</M>. Finally we note that
all elements lie in <A>Source( f )</A>. <P/>
It is possible to add an extra optional argument: <A>method:= "Carrier"</A>,
or <A>method:= "WeylOrbit"</A>. Then a method based on finding carrier
algebras (respectively, computing orbits under the Weyl group) is chosen.
If no optional argument is chosen, then the system will make its own choice.
(In the case of outer automorphisms, currently the only available 
method is the one based on orbits of the Weyl group.) The method based
on carrier algebras tends to work better for the higher order automorphisms.
<P/>
This function prints some information on what it is doing to the info
class <A>InfoSLA</A>. In order to suppress these messages one can 
do <A>SetInfoLevel( InfoSLA, 1 );</A>.
<P/>
In the two-argument version, the first argument <A>L</A> has to be a 
semisimple Lie algebra, and the second argument <A>d</A> a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works the same in this case
as in the one-argument version.


<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "D", 5, 3 );;   
gap> s:= NilpotentOrbitsOfThetaRepresentation( f[2] : method:= "Carrier" );; time;
#I  Selected carrier algebra method.
#I  Constructed 123 root bases of possible flat subalgebras, now checking them...
#I  Obtained 30 Cartan elements, weeding out equivalent copies...
776
gap> Length(s);
10
gap> s[4];
[ v.14+v.15+v.38, (-2)*v.41+(-1)*v.42, v.18+v.34+v.35 ]
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> NilpotentOrbitsOfThetaRepresentation( L, [0,1,0,0,0,0] );
#I  Selected Weyl orbit method.
#I  Constructed a Weyl transversal of 72 elements.
#I  Obtained 5 Cartan elements, weeding out equivalent copies...
[ [ v.65+v.66+v.67, (2)*v.73+(3)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
      v.29+v.30+v.31 ], 
  [ (2)*v.55+(2)*v.66, (2)*v.73+(4)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
      v.19+v.30 ], 
  [ v.63+v.71, (2)*v.73+(2)*v.74+(3)*v.75+(4)*v.76+(3)*v.77+(2)*v.78, 
      v.27+v.35 ], [ v.71, v.73+v.74+(2)*v.75+(3)*v.76+(2)*v.77+v.78, v.35 ] ]
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="ClosureDiagram"  Arg="L, f, s" 
         Comm="Lie algebra, automorphism, list of sl2-triples"/>
   <Oper Name="ClosureDiagram"  Arg="L, d, s" 
         Comm="Lie algebra, grading diagram, list of sl2-triples"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>, and <A>s</A> a list of 
<M>sl_2</M>-triples <M>(y,h,x)</M>, with <M>h\in L_0</M>, <M>x\in L_1</M>
(for instance as computed by the previous function), corresponding to nilpotent
orbits in <M>L_1</M>.
<P/>
This function computes the Hasse diagram of the closures of
the nilpotent orbits. The output is a record with two components:
<A>diag</A> (which is a list of 2-tuples; a tuple <A>[ i, j ]</A> means
that orbit number <A>i</A> is contained in the closure of orbit number
<A>j</A>), and <A>sl2</A> (the same list of <M>sl_2</M>-triples, but sorted
according to decreasing dimension, i.e., the highest dimensional orbit
comes first). The numbering used in the tuples in <A>diag</A> corresponds
to the order in which the orbits appear in the component <A>sl2</A>.
<P/>
During the execution of the program a message is printed. This message 
either states that all inclusions have been proved, or lists a number of
possible inclusions, for which it could not be proved with absolute certainty
that these do not occur. This is due to the randomised nature of the algorithm:
if the algorithm finds an inclusion, then this inclusion is certain.
However, sometimes a non-inclusion can only be estabished by random methods,
which means that it is possible that there is an inclusion without the
program finding it. (This however, is very unlikely, and in practice almost
never happens.) Now showing that a non-inclusion really is a non-inclusion
can be done by computing the ranks of certain matrices with polynomial entries.
In principle &GAP; can do this; however, the system certainly is not very strong
at it. Therefore, as optional argument a filename can be given, by
<A>filenm:= "file.m"</A>. If this argument
is present the program prints a Magma script in the file, which can be loaded
directly into the computer algebra system Magma. If the output is always true, 
then all non-inclusions are proved. If there are non non-inclusions to be 
proved, then the file is not written.
<P/>
In the second version, the second argument <A>d</A> is a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works in the same way.
<P/>
We note that the adjoint representation can be obtained by giving a <A>d</A>
that eintirely consists of zeros.


<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "E", 8, 8 );;  
gap> h:= f[8];;
gap> sl2:= NilpotentOrbitsOfThetaRepresentation(h);;  
#I  Selected carrier algebra method.
#I  Constructed 2782 root bases of possible flat subalgebras, now checking them...
#I  Obtained 58 Cartan elements, weeding out equivalent copies...
gap> time;
117792
gap> Length(sl2);
27
gap> L:= Source(h);;                    
gap> r:= ClosureDiagram( L, h, sl2 );;  
#I  All (non-) inclusions proved!
gap> time;
329248
gap> r.diag;
[ [ 2, 1 ], [ 3, 1 ], [ 4, 2 ], [ 4, 3 ], [ 5, 1 ], [ 6, 5 ], [ 7, 2 ], [ 7, 5 ], 
[ 8, 4 ], [ 9, 3 ], [ 9, 6 ], [ 10, 6 ], [ 10, 7 ], [ 11, 4 ], [ 11, 7 ], [ 12, 7 ], 
[ 13, 9 ], [ 13, 10 ], [ 13, 11 ], [ 14, 11 ], [ 14, 12 ], [ 15, 6 ], [ 16, 8 ], 
[ 16, 11 ], [ 17, 13 ], [ 17, 16 ], [ 18, 13 ], [ 18, 15 ], [ 19, 10 ], [ 19, 12 ], 
[ 19, 15 ], [ 20, 14 ], [ 20, 16 ], [ 21, 9 ], [ 21, 15 ], [ 22, 14 ], [ 22, 18 ], 
[ 22, 19 ], [ 23, 18 ], [ 23, 21 ], [ 24, 17 ], [ 24, 18 ], [ 25, 20 ], [ 25, 22 ], 
[ 25, 24 ], [ 26, 22 ], [ 26, 23 ], [ 27, 23 ], [ 27, 24 ] ]
# Now we do the adjoint representation of the Lie algebra of type F4:
gap> L:= SimpleLieAlgebra("F",4,Rationals);;
gap> o:= NilpotentOrbits(L);;
gap> sl2:= List( o, SL2Triple );;
gap> r:= ClosureDiagram( L, [0,0,0,0], sl2 );;      
#I  All (non-) inclusions proved!
gap> r.diag;
[ [ 2, 1 ], [ 3, 2 ], [ 4, 3 ], [ 5, 3 ], [ 6, 5 ], [ 6, 4 ], [ 7, 6 ], [ 8, 7 ], 
  [ 9, 7 ], [ 10, 9 ], [ 10, 8 ], [ 11, 8 ], [ 12, 10 ], [ 13, 12 ], [ 13, 11 ], 
  [ 14, 13 ], [ 15, 14 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CarrierAlgebra"  Arg="L, f, e" 
         Comm="Lie algebra, automorphism, element of L"/>
   <Oper Name="CarrierAlgebra"  Arg="L, d, e" 
         Comm="Lie algebra, grading diagram, element of L"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>, and <A>e</A> a nilpotent element
of <M>L_1</M>. This function returns the carrier algebra of <A>e</A>.
This is a <M>\mathbb{Z}</M>-graded semisimple subalgebra <M>K</M> of
<M>L</M>, such that <A>e</A> lies in <M>K_1</M>. For the precise 
definition we refer to <Cite Key="vinberg2"/>, <Cite Key="vinberg3"/>.  
The output is given
in the form of a record, with three components: <A>g0</A>, a basis of
<M>K_0</M>, <A>gp</A> a list containing bases of <M>K_1</M>, <M>K_2</M> and so
on, and <A>gn</A> a list containing bases of <M>K_{-1}</M>, <M>K_{-2}</M> and
so on.
<P/>
In the second version, the second argument <A>d</A> is a list of 
non-negative integers. Then <A>L</A> is <M>Z</M>-graded by giving 
the root space corresponding to the <M>i</M>-th simple root the degree
<A>d[i]</A>. Apart from this the function works in the same way.
<P/>


<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "F", 4, 5 );;
gap> h:= f[4];;
gap> sl2:= NilpotentOrbitsOfThetaRepresentation( h );;  
#I  Selected Weyl orbit method.
#I  Constructed a Weyl transversal of 144 elements.
#I  Constructed 621 Cartan elements to be checked.
gap> L:= Source(h);   
&lt;Lie algebra of dimension 52 over CF(5)>
gap> r:=CarrierAlgebra( L, h, sl2[1][3] );   
rec( g0 := [ v.49+(2)*v.50+(2)*v.51+(3)*v.52, v.50+(1/2)*v.51+v.52 ], 
gp := [ [ v.9, v.48 ], [ v.45 ], [ v.39 ] ], 
gn := [ [ v.24, v.33 ], [ v.21 ], [ v.15 ] ] )
gap> K:= Subalgebra( L, Concatenation( r.g0, Flat(r.gp), Flat(r.gn) ) );
&lt;Lie algebra over CF(5), with 10 generators>
gap> SemiSimpleType( K );
"B2"
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="CartanSubspace"  Arg="f" 
         Comm="automorphism"/>

   <Description>

Here <A>f</A> is an automorphism of a simple Lie algebra
<M>L</M> of order <M>m</M>. Then <A>f</A> defines a grading on
<M>L</M>. Let the homogeneous components of this grading be denoted
<M>L_i</M> for <M>i=0,...,m-1</M>. Let <M>G_0</M> be the group corresponding
to <M>L_0</M> (i.e., the connected subgroup of the adjoint group of
<M>L</M> with Lie algebra <M>L_0</M>). This function computes a maximal
subspace of <M>L_1</M> consisting of commuting semisimple elements.
(Such a subspace is called a <E>Cartan subspace</E>.)
<P/> 
Every semisimple orbit of <M>G_0</M> in <M>L_1</M> contains an element
of a fixed Cartan subspace.

<Example>
gap> f:= FiniteOrderInnerAutomorphisms( "A", 3, 3 );;
gap> c:= CartanSubspace( f[3] ); 
&lt;vector space of dimension 1 over CF(3)>
gap> BasisVectors( Basis( c ) );
[ v.1+v.5+v.12 ]
</Example>

</Description>
</ManSection>


</Section>


</Chapter>

<Chapter> <Heading>Semisimple Subalgebras of Semisimple Lie Algebras</Heading>


This chapter contains functions for dealing with semisimple subalgebras
of semisimple Lie algebras. There are functions for computing branching rules,
for computing the regular subalgebras, and for working with the database
of semisimple subalgebras of the simple Lie algebras.

This last database contains the semisimple subalgebras of the simple
Lie algebras of ranks up to 8. The semisimple subalgebras are classified
up to linear equivalence. (Two subalgebras are called linearly equivalent 
if for every representation of the big algebra in the space <M>V</M>
the images of the subalgebras are conjugate under <M>GL(V)</M>.)




<Section> <Heading> Branching </Heading>

<ManSection>
   <Oper Name="ProjectionMatrix"  Arg="L, K" 
         Comm="two Lie algebras"/>
   <Description>

Here <A>L</A> and <A>K</A> are semisimple Lie algebras with the following
properties: <A>K</A> is contained in <A>L</A>,
the Cartan subalgebra of <A>L</A>, as returned by 
<A>CartanSubalgebra(L)</A> is split (this is automatic if <A>L</A> is
created by the built in &GAP; function) and <A>K</A> has a Cartan subalgebra
that is a subalgebra of the Cartan subalgebra of <A>L</A>. We note that
the function checks only the last property. The function returns a matrix
<A>P</A> such that if <A>u</A> is a weight of a <A>L</A>-module <M>V</M>, then
<A>P*u</A> is a weight of <A>V</A>, when considered as a <A>K</A>-module.

<Example>
gap> L:= SimpleLieAlgebra("E",7,Rationals);;                
gap> K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               
> L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;
gap> Dimension(K);
63
gap> SemiSimpleType(K);
"A7"
gap> ProjectionMatrix( L, K );
[ [ 2, 2, 3, 4, 3, 2, 1 ], [ 0, 0, -1, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 0, 0, 0 ],
  [ 0, 0, 0, 0, -1, 0, 0 ], [ 0, 0, 0, 0, 0, -1, 0 ], 
  [ 0, 0, 0, 0, 0, 0, -1 ], [ -1, -2, -2, -3, -2, -1, 0 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Oper Name="Branching"  Arg="L, K, hw" 
         Comm="two Lie algebras"/>
   <Description>

Here <A>L</A> and <A>K</A> are as in the previous function, and <A>hw</A> is
the highest weight of an irreducible <A>L</A>-module. This function computes
the splitting of the module when seen as a <A>K</A>-module. Returned is a 
list of two lists: the first list contains the highest weights of the 
modules involved, the second list contains their multiplicities.


<Example>
gap> L:= SimpleLieAlgebra("E",7,Rationals);;                
gap> K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               
> L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;
gap> Branching( L, K, [1,0,0,0,0,0,1] );
[ [ [ 1, 1, 0, 0, 0, 0, 1 ], [ 1, 1, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1, 0, 1 ],
      [ 0, 0, 1, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 0, 0 ], 
      [ 0, 1, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 1 ], 
      [ 0, 0, 1, 0, 0, 0, 0 ] ], [ 1, 1, 1, 1, 1, 1, 1, 1 ] ]
</Example>

</Description>
</ManSection>

</Section>

<Section> <Heading> Constructing Semisimple Subalgebras </Heading>

<ManSection>
   <Attr Name="RegularSemisimpleSubalgebras"  Arg="L" 
         Comm="a Lie algebra"/>
   <Description>

Here <A>L</A> is a <E>simple</E> Lie algebra. This function returns a
list of its conjugacy classes of semisimple subalgebras (conjugacy
under the adjoint group). 



<Example>
gap> L:= SimpleLieAlgebra("E",6,Rationals);;
gap> K:= RegularSemisimpleSubalgebras( L );; time;
1664
gap> Length(K);
19
gap> K[5];
&lt;Lie algebra of dimension 45 over Rationals>
gap> SemiSimpleType( K[5] ); 
"D5"
gap> Branching( L, K[5], [1,0,0,0,0,1] );     
[ [ [ 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 1 ], [ 1, 0, 0, 1, 0 ], 
      [ 1, 0, 0, 0, 1 ], [ 2, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
      [ 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0 ] ], 
  [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
</Example>

</Description>
</ManSection>

<ManSection>
   <Func Name="SSSTypes" Arg=""/>
   <Description>

This returns a list of the types of the semisimple Lie algebras of which
the database contains the classification of the semisimple subalgebras,
up to linear equivalence. (The three letters S stand for SemiSimple 
Subalgebras.)

</Description>
</ManSection>


<ManSection>
   <Oper Name="LieAlgebraAndSubalgebras" Arg="type"/>
   <Description>

Here <A>type</A> is a string describing the type of a semisimple Lie
algebra. A simple type is a capital letter (A, B, C, D, E, F, or G) followed
by a positive integer. Example: <A>"D5"</A>. In general a type is a sequence
of simple types separated by spaces. Example: <A>"A2 C3 E6"</A>.

This function is appliccable if each simple type that occurs in <A>type</A>
has rank less than or equal to 8.

In that case a record is returned with two components: <A>liealg</A>, which
is a semisimple Lie algebra of type <A>type</A>, and <A>subalgs</A> which
is the list of its semisimple subalgebras up to linear equivalence.

If <A>type</A> is a simple type then the list will be simply fetched from
the database. Otherwise a computation will be triggered, and afterwards the
database will be bigger. (One can check this with a call to <A>SSSTypes()</A>).
Also we remark that for non-simple types of not so small rank this computation
can be difficult.

</Description>
</ManSection>

<ManSection>
   <Oper Name="InclusionsGraph" Arg="type"/>
   <Description>

Here <A>type</A> is a string describing the type of a semisimple Lie
algebra. This is the same as in the previous function.

This function returns a list containing the edges of the inclusion graph
of the semisimple subalgebras returned by the previous function. An edge
is represented by a list of two integers. If the edge <A>[ i, j ]</A> occurs,
then this means that the subalgebra on position <A>j</A> in the list is
linearly equivalent to a subalgebra of the subalgebra in position <A>i</A>.

Only the maximal subalgebras are considered; so if we have edges <A>[ i, j ]</A>
and <A>[ j, k ]</A> then there will be no edge <A>[ i, k ]</A>. (Otherwise 
this list can become huge.)

Edges of the form <A>[ 0, j ]</A> express that the subalgebra on position
<A>j</A> is a maximal semisimple subalgebra of the Lie algebra of type 
<A>type</A>.

<Example>
# Semisimple subalgebras of the Lie algebra of type D4:
gap> s:= LieAlgebraAndSubalgebras( "D4" );;
gap> L:= s.liealg;
&lt;Lie algebra of dimension 28 over CF(3)>
gap> sub:= s.subalgs;;
gap> Length(sub);
44
gap> g:= InclusionsGraph( "D4" );;
gap> g[1];
[ 12, 1 ]

# Find the maximal semisimple subalgebras:

gap> m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );
[ 13, 35, 36, 37, 41, 42, 43, 44 ]
gap> List( sub{i}, SemiSimpleType );                
[ "A2", "A1 B2", "A1 B2", "A1 B2", "B3", "B3", "B3", "A1 A1 A1 A1" ]

# We see that the subalgebras on positions 35 and 36 are isomorphic;
# however they are not linearly equivalent:
gap> Branching( L, sub[35], [0,0,1,0] );
[ [ [ 1, 0, 1 ] ], [ 1 ] ]
gap> Branching( L, sub[36], [0,0,1,0] );
[ [ [ 0, 1, 0 ], [ 2, 0, 0 ] ], [ 1, 1 ] ]
</Example>
</Description>
</ManSection>

<ManSection>
   <Oper Name="SubalgebrasInclusion" Arg="L, K1, K2"/>
   <Description>

Here <A>K1</A>, <A>K2</A>, are two subalgebras of the semisimple Lie algebra
<A>L</A>, constructed using the database. If <A>K2</A> 
contains a subalgebra that is linearly equivalent to <A>K1</A> then
such a subalgebra is returned. Otherwise the result is <A>fail</A>.


<Example>
gap> s:= LieAlgebraAndSubalgebras( "C3" );;
gap> g:= InclusionsGraph( "C3" );
[ [ 10, 1 ], [ 11, 1 ], [ 12, 1 ], [ 8, 2 ], [ 10, 2 ], [ 11, 2 ], [ 11, 3 ], 
  [ 13, 3 ], [ 8, 4 ], [ 13, 4 ], [ 9, 5 ], [ 12, 5 ], [ 12, 6 ], [ 13, 6 ], 
  [ 0, 7 ], [ 0, 8 ], [ 15, 9 ], [ 9, 10 ], [ 14, 10 ], [ 14, 11 ], 
  [ 15, 12 ], [ 0, 13 ], [ 15, 14 ], [ 0, 15 ] ]
# there are the edges [ 14, 10] and [ 10, 2 ]; hence a conjugate of the
# second algebra is contained in the 14-th.
gap> L:= s.liealg;
&lt;Lie algebra of dimension 21 over Rationals>
gap> sub:= s.subalgs;;
gap> K:=SubalgebrasInclusion( L, sub[2], sub[14] );
&lt;Lie algebra of dimension 3 over Rationals>
gap> Basis(K)[1] in sub[14];
true
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="DynkinIndex" Arg="K, L"/>
   <Description>

Here <A>K</A> is a semisimple subalgebra of the <E>simple</E> Lie algebra
<A>L</A>. This function returns a list of integers, containing the Dynkin
indices of the simple components of <A>K</A>. If the input Lie algebra
<A>L</A> is not simple, then still a list of rationals is returned, but they
may have no meaning.

The Dynkin index is defined as follows. Consider a simple component
in <A>K</A> and let <M>h</M> be the coroot of the shortest root of <A>K</A>. 
Let <M>k</M> denote the Killing form of <A>L</A>, normalised so that
the coroot of the shortest root of <A>L</A> has squared length 2. 
Then the Dynkin index is <M>k(h,h)/2</M>.

<Example>
gap> s:= LieAlgebraAndSubalgebras( "C7" );;
gap> g:= InclusionsGraph( "C7" );;
gap> m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );
[ 63, 498, 665, 804, 819, 821, 822 ]
gap> L:= s.liealg;
&lt;Lie algebra of dimension 105 over Rationals>
gap> sub:= s.subalgs;;
gap> List( sub{i}, SemiSimpleType );   
[ "A1", "C3", "A1 B3", "A6", "C3 C4", "B2 C5", "A1 C6" ]
gap> DynkinIndex( sub[665], L );   
[ 7, 4 ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="AreLinearlyEquivalentSubalgebras" Arg="L, K1, K2"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra, and <A>K1</A>, <A>K2</A> are
subalgebras. It is assumed that the Cartan subalgebras (as returned by
<A>CartanSubalgebra</A>) of <A>K1</A>, <A>K2</A> are contained in the
Cartan subalgebra of <A>L</A> (otherwise <A>fail</A> is returned).
This function returns <A>true</A> if <A>K1</A>, <A>K2</A> are linearly 
equivalent, <A>false </A> otherwise.



<Example>
# Lets find the subalgebras in the database for C5 that are linearly
# equivalent to regular subalgebras:
gap> s:= LieAlgebraAndSubalgebras("C5");; L:= s.liealg; sub:= s.subalgs;;
&lt;Lie algebra of dimension 55 over Rationals>
gap> reg:= RegularSemisimpleSubalgebras( L );;
gap> posn:= [];;
gap> for K in reg do  
> Add(posn,PositionProperty(sub,M -> AreLinearlyEquivalentSubalgebras(L,M,K)));
> od;
gap> posn;
[ 2, 24, 93, 111, 105, 82, 106, 81, 41, 109, 70, 85, 29, 112, 94, 25, 1, 118, 
  100, 102, 64, 108, 84, 28, 117, 107, 116, 96, 101, 63, 115, 114, 95, 113 ]
</Example>


</Description>
</ManSection>

<ManSection>

   <Oper Name="MakeDatabaseEntry" Arg="r"/>
   <Oper Name="AddToDatabase" Arg="d"/>

   <Description>

These are functions that help to save a computed list of subalgebras of a 
semisimple Lie algebra in a file, and in a new session, read it again.

In the first function <A>r</A> is a record as produced by 
<Ref Oper="LieAlgebraAndSubalgebras"/>. It returns a record that can be saved
in a file. (It is not advisable to print it on the screen.)

In the second function <A>d</A> is a record that is output by
<Ref Oper="MakeDatabaseEntry"/>. This function adds this entry to the database.
<P/>
We give two examples; in the first one we create a new database entry,
and save it to a file. In the second example we read it and add it to the
database.

<Example>
gap> r:= LieAlgebraAndSubalgebras( "A2 B2" );;
gap> d:= MakeDatabaseEntry( r );;
gap> PrintTo( "A2B2", "d:= ",d,";\n");
</Example>

<Example>
gap> Read("A2B2");
gap> AddToDatabase( d );
gap> SSSTypes();
[ "A1", "A2", "B2", "G2", "A3", "B3", "C3", "A4", "B4", "C4", "D4", "F4", 
  "A5", "B5", "C5", "D5", "A6", "B6", "C6", "D6", "E6", "A7", "B7", "C7", 
  "D7", "E7", "A8", "B8", "C8", "D8", "E8", "A2 B2" ]
</Example>


</Description>
</ManSection>

<ManSection>
   <Oper Name="ClosedSubsets" Arg="R"/>
   <Description>

Here <A>R</A> is a root system. A subset <M>S</M> of the roots of <A>R</A> is
said to be closed if for all <M>a,b\in S</M> we have that <M>a+b</M> lies in
<M>S</M> whenever <M>a+b</M> is a root. This function computes the list of the
closed subsets of <A>R</A> up to conjugacy by the Weyl group. In other words,
each closed subset of <A>R</A> is conjugate under the Weyl group to exactly
one element of the output of this function.

The output is a list of which each element is a list of roots. A root in
such a list, or its negative, lies in the attribute
<A>PositiveRootsNF( R )</A>.


<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);; time;
10812
gap> Length(c);
4844
gap> c[1005];
[ [ 1, 1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 2, 0 ], [ 0, 1, 1, 1 ], 
  [ 1, 1, 1, 1 ], [ 1, 2, 2, 0 ], [ 1, 1, 2, 1 ], [ 0, 1, 2, 2 ], 
  [ 1, 1, 2, 2 ], [ 1, 2, 3, 1 ], [ 1, 2, 2, 2 ], [ 1, 2, 3, 2 ], 
  [ 1, 2, 4, 2 ], [ 1, 3, 4, 2 ], [ 2, 3, 4, 2 ], [ 0, -1, -2, 0 ] ]
</Example>


</Description>
</ManSection>


<ManSection>
   <Oper Name="DecompositionOfClosedSet" Arg="c"/>
   <Description>

Here <A>c</A> is a closed set of roots of some root system. We have that 
<A>c</A> is the disjoint union of its symmetric part (consisting of all
roots <M>a</M> in <A>c</A> such that <M>-a</M> also lies in <A>c</A>) and
its special part (consisting of all
roots <M>a</M> in <A>c</A> such that <M>-a</M> does not lie in <A>c</A>).
This function returns a list of two entries. The first is the symmetric part of
<A>c</A>, the second is the special part of <A>c</A>.

<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);;
gap> DecompositionOfClosedSet( c[1005] );
[ [ [ 0, 1, 2, 0 ], [ 0, -1, -2, 0 ] ], 
  [ [ 1, 1, 0, 0 ], [ 0, 0, 1, 1 ], [ 0, 1, 1, 1 ], [ 1, 1, 1, 1 ], 
      [ 1, 2, 2, 0 ], [ 1, 1, 2, 1 ], [ 0, 1, 2, 2 ], [ 1, 1, 2, 2 ], 
      [ 1, 2, 3, 1 ], [ 1, 2, 2, 2 ], [ 1, 2, 3, 2 ], [ 1, 2, 4, 2 ], 
      [ 1, 3, 4, 2 ], [ 2, 3, 4, 2 ] ] ]
</Example>


</Description>
</ManSection>


<ManSection>
   <Oper Name="IsSpecialClosedSet" Arg="c"/>
   <Description>

Here <A>c</A> is a closed set of roots of some root system. This function
returns <A>true</A> is <A>c</A> is special (that is, for all <M>a</M> in
<A>c</A> we have that <M>-a</M> does not lie in <A>c</A>), otherwise it
returns <A>false</A>.


<Example>
gap> R:= RootSystem("F",4);
&lt;root system of type F4>
gap> c:= ClosedSubsets(R);;
gap> IsSpecialClosedSet( c[1005] );
false
gap> IsSpecialClosedSet( c[1006] );
true
gap> Length( Filtered( c, IsSpecialClosedSet ) );
3579
</Example>

</Description>
</ManSection>


<ManSection>
   <Oper Name="LieAlgebraOfClosedSet" Arg="L, c"/>
   <Description>

Here <A>L</A> is a semisimple Lie algebra and 
<A>c</A> is a closed set of roots of its root system.
This function returns the subalgebra of <A>L</A> spanned a the Cartan
subalgebra of <A>L</A> (the one relative to which the root system is
taken) along with the root vectors corresponding to the roots in
<A>c</A>.

<Example>
gap> L:= SimpleLieAlgebra("F",4,Rationals);
&lt;Lie algebra of dimension 52 over Rationals>
gap> R:= RootSystem( L );
&lt;root system of rank 4>
gap> c:= ClosedSubsets(R);; 
gap> c[1005];
[ [ 1, 0, 1, 0 ], [ 0, 1, 0, 1 ], [ 1, 0, 1, 1 ], [ 0, 0, 2, 1 ], 
  [ 1, 1, 1, 1 ], [ 1, 1, 2, 1 ], [ 2, 0, 2, 1 ], [ 0, 1, 2, 2 ], 
  [ 2, 1, 2, 1 ], [ 1, 1, 3, 2 ], [ 2, 1, 2, 2 ], [ 2, 1, 3, 2 ], 
  [ 2, 1, 4, 2 ], [ 2, 1, 4, 3 ], [ 2, 2, 4, 3 ], [ 0, 0, -2, -1 ] ]
gap> K:= SubalgebraOfClosedSet( L, c[1005] );
&lt;Lie algebra of dimension 20 over Rationals>
gap> LeviMalcevDecomposition(K);
[ &lt;Lie algebra of dimension 3 over Rationals>, 
  &lt;two-sided ideal in &lt;Lie algebra of dimension 20 over Rationals>, 
      (dimension 17)> ]
</Example>


</Description>
</ManSection>


</Section>
</Chapter>


</Body>

<Bibliography Databases="sla" />

<TheIndex/>


</Book>

% generated by GAPDoc2LaTeX from XML source (Frank Luebeck)
\documentclass[a4paper,11pt]{report}

\usepackage{a4wide}
\sloppy
\pagestyle{myheadings}
\usepackage{amssymb}
\usepackage[latin1]{inputenc}
\usepackage{makeidx}
\makeindex
\usepackage{color}
\definecolor{FireBrick}{rgb}{0.5812,0.0074,0.0083}
\definecolor{RoyalBlue}{rgb}{0.0236,0.0894,0.6179}
\definecolor{RoyalGreen}{rgb}{0.0236,0.6179,0.0894}
\definecolor{RoyalRed}{rgb}{0.6179,0.0236,0.0894}
\definecolor{LightBlue}{rgb}{0.8544,0.9511,1.0000}
\definecolor{Black}{rgb}{0.0,0.0,0.0}

\definecolor{linkColor}{rgb}{0.0,0.0,0.554}
\definecolor{citeColor}{rgb}{0.0,0.0,0.554}
\definecolor{fileColor}{rgb}{0.0,0.0,0.554}
\definecolor{urlColor}{rgb}{0.0,0.0,0.554}
\definecolor{promptColor}{rgb}{0.0,0.0,0.589}
\definecolor{brkpromptColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapinputColor}{rgb}{0.589,0.0,0.0}
\definecolor{gapoutputColor}{rgb}{0.0,0.0,0.0}

%%  for a long time these were red and blue by default,
%%  now black, but keep variables to overwrite
\definecolor{FuncColor}{rgb}{0.0,0.0,0.0}
%% strange name because of pdflatex bug:
\definecolor{Chapter }{rgb}{0.0,0.0,0.0}
\definecolor{DarkOlive}{rgb}{0.1047,0.2412,0.0064}


\usepackage{fancyvrb}

\usepackage{mathptmx,helvet}
\usepackage[T1]{fontenc}
\usepackage{textcomp}


\usepackage[
            pdftex=true,
            bookmarks=true,        
            a4paper=true,
            pdftitle={Written with GAPDoc},
            pdfcreator={LaTeX with hyperref package / GAPDoc},
            colorlinks=true,
            backref=page,
            breaklinks=true,
            linkcolor=linkColor,
            citecolor=citeColor,
            filecolor=fileColor,
            urlcolor=urlColor,
            pdfpagemode={UseNone}, 
           ]{hyperref}

\newcommand{\maintitlesize}{\fontsize{50}{55}\selectfont}

% write page numbers to a .pnr log file for online help
\newwrite\pagenrlog
\immediate\openout\pagenrlog =\jobname.pnr
\immediate\write\pagenrlog{PAGENRS := [}
\newcommand{\logpage}[1]{\protect\write\pagenrlog{#1, \thepage,}}
%% were never documented, give conflicts with some additional packages

\newcommand{\GAP}{\textsf{GAP}}

%% nicer description environments, allows long labels
\usepackage{enumitem}
\setdescription{style=nextline}

%% depth of toc
\setcounter{tocdepth}{1}





%% command for ColorPrompt style examples
\newcommand{\gapprompt}[1]{\color{promptColor}{\bfseries #1}}
\newcommand{\gapbrkprompt}[1]{\color{brkpromptColor}{\bfseries #1}}
\newcommand{\gapinput}[1]{\color{gapinputColor}{#1}}


\begin{document}

\logpage{[ 0, 0, 0 ]}
\begin{titlepage}
\mbox{}\vfill

\begin{center}{\maintitlesize \textbf{SLA\mbox{}}}\\
\vfill

\hypersetup{pdftitle=SLA}
\markright{\scriptsize \mbox{}\hfill SLA \hfill\mbox{}}
{\Huge \textbf{Simple Lie Algebras\mbox{}}}\\
\vfill

{\Huge Version 1.2\mbox{}}\\[1cm]
{November 2016\mbox{}}\\[1cm]
\mbox{}\\[2cm]
{\Large \textbf{ Willem de Graaf    \mbox{}}}\\
\hypersetup{pdfauthor= Willem de Graaf    }
\end{center}\vfill

\mbox{}\\
{\mbox{}\\
\small \noindent \textbf{ Willem de Graaf    }  Email: \href{mailto://degraaf@science.unitn.it} {\texttt{degraaf@science.unitn.it}}\\
  Homepage: \href{http://www.science.unitn.it/~degraaf/} {\texttt{http://www.science.unitn.it/\texttt{\symbol{126}}degraaf/}}\\
  Address: \begin{minipage}[t]{8cm}\noindent
 Dipartimento di Matematica\\
 Via Sommarive 14\\
 I-38050 Povo (Trento)\\
 Italy\\
 \end{minipage}
}\\
\end{titlepage}

\newpage\setcounter{page}{2}
{\small 
\section*{Abstract}
\logpage{[ 0, 0, 1 ]}
 This package provides functions for computing with various aspects of the
theory of simple Lie algebras in characteristic zero. \mbox{}}\\[1cm]
{\small 
\section*{Copyright}
\logpage{[ 0, 0, 2 ]}
 {\copyright} 2016 Willem de Graaf \mbox{}}\\[1cm]
\newpage

\def\contentsname{Contents\logpage{[ 0, 0, 3 ]}}

\tableofcontents
\newpage

 
\chapter{\textcolor{Chapter }{Introduction}}\logpage{[ 1, 0, 0 ]}
\hyperdef{L}{X7DFB63A97E67C0A1}{}
{
  This package is a collection of functions that I wrote for various research
projects (e.g., \cite{wdg08}, \cite{gra15}, \cite{elasgra}, \cite{grasss}, \cite{closure}). The reason to collect them in a package is to avoid them getting lost.
Secondly, I believe that the functions may be of wider interest. 

 Apart from this one, this manual has four chapters. The second describes
various functions that did not fit in any of the other chapters. They vary
from short utility functions to functions implementing rather complex
algorithms. The remaining three chapters are all devoted to a particular area.

 The third chapter contains (descriptions of) functions for computing with the
classification of the nilpotent orbits in simple Lie algebras. There are
functions for creating the orbits and for computing representatives. We refer
to \cite{colmcgov} for an overview of the theory of nilpotent orbits in simple Lie algebras. 

 The fourth chapter is dedicated to finite order automorphisms of the simple
Lie algebras and the corresponding $\theta$-groups. The finite order automorphisms have been classified by Kac, up to
conjugacy in the automorphism group. For the background on this we refer to \cite{helgason}. The classification is described in terms of so-called Kac diagrams. The
package contains a function for creating all automorphisms of a given simple
Lie algebra, of a given finite order. 

 The eigenspaces of an automorphism of finite order of a simple Lie algebra
form a grading of that Lie algebra. Moreover, the 0-component is a reductive
subalgebra, acting on the 1-component. The 0-component corresponds to a
reductive reductive group, also acting on the 1-component. This group (with
its action) is called a $\theta$-group. It was introduced and studied in the 70-s by Vinberg (\cite{vinberg3} , \cite{vinberg}, \cite{vinberg2}) The package has a function for listing the nilpotent orbits of this group. 

 The fifth chapter has functions for working with semisimple subalgebras of
semisimple Lie algebras. The package contains a database of semisimple
subalgebras of the simple subalgebras of ranks up to 8. Moreover, there are
functions for computing the semisimple subalgebras of semisimple Lie algebras
on the fly. Finally, there are some functions for computing branching rules. 

 We remark that the package needs the package \textsf{QuaGroup}. }

 
\chapter{\textcolor{Chapter }{Auxiliary Functions}}\logpage{[ 2, 0, 0 ]}
\hyperdef{L}{X866E18057EF83F65}{}
{
  This chapter contains the description of some functions that do not fit in any
other chapter. 
\section{\textcolor{Chapter }{ Root Systems }}\logpage{[ 2, 1, 0 ]}
\hyperdef{L}{X7D22A7DF7EF96F24}{}
{
  

\subsection{\textcolor{Chapter }{ExtendedCartanMatrix}}
\logpage{[ 2, 1, 1 ]}\nobreak
\hyperdef{L}{X8122C42F7CCFC6ED}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ExtendedCartanMatrix({\mdseries\slshape R})\index{ExtendedCartanMatrix@\texttt{ExtendedCartanMatrix}}
\label{ExtendedCartanMatrix}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape R}} is a root system. This function returns the extended Cartan matrix of \mbox{\texttt{\mdseries\slshape R}}. That is the Cartan matrix correponding to the lowest root (coming first),
and the simple roots of \mbox{\texttt{\mdseries\slshape R}}. 

 The output is a record with components \mbox{\texttt{\mdseries\slshape ECM}} (the extended Cartan matrix) and \mbox{\texttt{\mdseries\slshape labels}} (the labels of the corresponding Dynkin diagram; they are the integer
coefficients of a linear dependency of the roots corresponding to the nodes). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:= RootSystem("F",4);;|
  !gapprompt@gap>| !gapinput@ExtendedCartanMatrix(R);|
  rec( ECM := [ [ 2, -1, 0, 0, 0 ], [ -1, 2, -1, 0, 0 ], [ 0, -1, 2, -2, 0 ], 
        [ 0, 0, -1, 2, -1 ], [ 0, 0, 0, -1, 2 ] ], labels := [ 1, 2, 3, 4, 2 ] )
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CartanType}}
\logpage{[ 2, 1, 2 ]}\nobreak
\hyperdef{L}{X7DABAF857F49C8EB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CartanType({\mdseries\slshape C})\index{CartanType@\texttt{CartanType}}
\label{CartanType}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape C}} is a Cartan matrix (i.e., an integer matrix with 2-s on the diagonal,
non-positive entries otherwise, and there exists a diagonal integer matrix \mbox{\texttt{\mdseries\slshape D}} such that \mbox{\texttt{\mdseries\slshape CD}} is a positive definite symmetric matrix). This function returns a record with
two components: \mbox{\texttt{\mdseries\slshape types}}, a list containing the types of the simple components of the corresponding
root system, and \mbox{\texttt{\mdseries\slshape enumeration}}, a standard enumeration of the vertices of the Dynkin diagram of \mbox{\texttt{\mdseries\slshape C}}. So this can be used to construct isomorphisms of root systems. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@C:= [[2,0,-3,0],[0,2,0,-1],[-1,0,2,0],[0,-1,0,2]];|
  [ [ 2, 0, -3, 0 ], [ 0, 2, 0, -1 ], [ -1, 0, 2, 0 ], [ 0, -1, 0, 2 ] ]
  !gapprompt@gap>| !gapinput@CartanType(C);|
  rec( types := [ [ "G", 2 ], [ "A", 2 ] ], 
    enumeration := [ [ 3, 1 ], [ 2, 4 ] ] )
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{WeylTransversal}}
\logpage{[ 2, 1, 3 ]}\nobreak
\hyperdef{L}{X8789147A7A570A01}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeylTransversal({\mdseries\slshape R, inds})\index{WeylTransversal@\texttt{WeylTransversal}}
\label{WeylTransversal}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeylTransversal({\mdseries\slshape R, roots})\index{WeylTransversal@\texttt{WeylTransversal}}
\label{WeylTransversal}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape R}} is a root system, and \mbox{\texttt{\mdseries\slshape inds}} a list of indices of \emph{positive} roots of \mbox{\texttt{\mdseries\slshape R}} that form a set of simple roots of a root subsystem of \mbox{\texttt{\mdseries\slshape R}} (the system does not check this). Here an index of a positive root is its
position in the list \mbox{\texttt{\mdseries\slshape PositiveRootsNF( R )}}.

 This function returns a list of shortest representatives of the right cosets
of the corresponding Weyl subgroup of the Weyl group of \mbox{\texttt{\mdseries\slshape R}}. The elements of the Weyl group are given as reduced expressions. 

 In the second form \mbox{\texttt{\mdseries\slshape rts}} is a list of roots of \mbox{\texttt{\mdseries\slshape R}}, that form a set of simple roots of a root subsystem of \mbox{\texttt{\mdseries\slshape R}} (again, this is not checked). In this form the roots so not have to be
positive. They have to be represented with respect to the basis of simple
roots, i.e., they are elements of \mbox{\texttt{\mdseries\slshape PositiveRootsNF(R)}} or of \mbox{\texttt{\mdseries\slshape NegativeRootsNF(R)}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:= RootSystem("A",3);;|
  !gapprompt@gap>| !gapinput@WeylTransversal( R, [2,6] );|
  [ [  ], [ 1 ], [ 3 ], [ 1, 2 ], [ 1, 3 ], [ 3, 2 ] ]
  !gapprompt@gap>| !gapinput@R:= RootSystem("E",8);;|
  !gapprompt@gap>| !gapinput@p:= PositiveRootsNF(R);;|
  !gapprompt@gap>| !gapinput@a:= WeylTransversal( R, [p[1],p[3],p[4],p[5],p[6],p[7],p[8],-p[120]] );;|
  !gapprompt@gap>| !gapinput@Length(a);|
  1920
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SizeOfWeylGroup}}
\logpage{[ 2, 1, 4 ]}\nobreak
\hyperdef{L}{X78A375CD80A0F31E}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SizeOfWeylGroup({\mdseries\slshape R})\index{SizeOfWeylGroup@\texttt{SizeOfWeylGroup}}
\label{SizeOfWeylGroup}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SizeOfWeylGroup({\mdseries\slshape type})\index{SizeOfWeylGroup@\texttt{SizeOfWeylGroup}}
\label{SizeOfWeylGroup}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SizeOfWeylGroup({\mdseries\slshape X, n})\index{SizeOfWeylGroup@\texttt{SizeOfWeylGroup}}
\label{SizeOfWeylGroup}
}\hfill{\scriptsize (operation)}}\\


 In the first from \mbox{\texttt{\mdseries\slshape R}} is a root system. In the second form \mbox{\texttt{\mdseries\slshape type}} is a list of lists describing the type of a root system. For example: \mbox{\texttt{\mdseries\slshape [["A",3],["B",5],["G",2]]}}. In the third form \mbox{\texttt{\mdseries\slshape X}} is a letter (i.e., a string) and \mbox{\texttt{\mdseries\slshape n}} a positive integer, so that \mbox{\texttt{\mdseries\slshape  Xn}} is the type of a root system. In all cases the number of elements of the Weyl
group is returned. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@R:= RootSystem( SimpleLieAlgebra("E",6,Rationals) );;|
  !gapprompt@gap>| !gapinput@SizeOfWeylGroup(R);                |
  51840
  !gapprompt@gap>| !gapinput@SizeOfWeylGroup( [["E",6]] );|
  51840
  !gapprompt@gap>| !gapinput@SizeOfWeylGroup( "E", 6 );   |
  51840
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{ Lie Algebras and Their Modules }}\logpage{[ 2, 2, 0 ]}
\hyperdef{L}{X78851B9C8710F7FD}{}
{
  

\subsection{\textcolor{Chapter }{IsomorphismOfSemisimpleLieAlgebras}}
\logpage{[ 2, 2, 1 ]}\nobreak
\hyperdef{L}{X7FA167DB80B7D701}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{IsomorphismOfSemisimpleLieAlgebras({\mdseries\slshape L1, L2})\index{IsomorphismOfSemisimpleLieAlgebras@\texttt{IsomorphismOfSemisimpleLieAlgebras}}
\label{IsomorphismOfSemisimpleLieAlgebras}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L1}} and \mbox{\texttt{\mdseries\slshape L2}} are two semisimple Lie algebras that are known to be isomorphic (i.e., they
have the same type). This function returns an isomorphism. }

 

\subsection{\textcolor{Chapter }{AdmissibleLattice}}
\logpage{[ 2, 2, 2 ]}\nobreak
\hyperdef{L}{X7866133B814EA2B2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AdmissibleLattice({\mdseries\slshape V})\index{AdmissibleLattice@\texttt{AdmissibleLattice}}
\label{AdmissibleLattice}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape V}} is a \emph{simple} module over a semisimple Lie algebra. This function returns a basis of \mbox{\texttt{\mdseries\slshape V}} that spans an admissible lattice in \mbox{\texttt{\mdseries\slshape V}}. This means that for a root vector $x$ of the acting Lie algebra the matrix $exp( mx )$ is integral, where $mx$ denotes the matrix of $x$ relative to the admissible lattice. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("G",2,Rationals);;|
  !gapprompt@gap>| !gapinput@V:= HighestWeightModule( L, [2,0] );|
  <27-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
  !gapprompt@gap>| !gapinput@B:=AdmissibleLattice(V);;|
  !gapprompt@gap>| !gapinput@x:= L.1;|
  v.1
  !gapprompt@gap>| !gapinput@mx:= MatrixOfAction( B, x );;|
  !gapprompt@gap>| !gapinput@IsZero(mx^4); IsZero(mx^5);|
  false
  true
  !gapprompt@gap>| !gapinput@exp:=Sum( List( [0..4], i -> mx^i/Factorial(i) ) );;|
  !gapprompt@gap>| !gapinput@ForAll( Flat(exp), IsInt );|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DirectSumDecomposition}}
\logpage{[ 2, 2, 3 ]}\nobreak
\hyperdef{L}{X7A4E769A87A9B2B3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DirectSumDecomposition({\mdseries\slshape V})\index{DirectSumDecomposition@\texttt{DirectSumDecomposition}}
\label{DirectSumDecomposition}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape V}} is a module over a semisimple Lie algebra; this function computes a list of
sub-modules such that \mbox{\texttt{\mdseries\slshape V}} is their direct sum. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("G",2,Rationals);;|
  !gapprompt@gap>| !gapinput@V:= HighestWeightModule( L, [1,0] );;|
  !gapprompt@gap>| !gapinput@W:= TensorProductOfAlgebraModules( V, V );|
  <49-dimensional left-module over <Lie algebra of dimension 14 over Rationals>>
  !gapprompt@gap>| !gapinput@DirectSumDecomposition( W );|
  [ <left-module over <Lie algebra of dimension 14 over Rationals>>, 
    <left-module over <Lie algebra of dimension 14 over Rationals>>, 
    <left-module over <Lie algebra of dimension 14 over Rationals>>, 
    <left-module over <Lie algebra of dimension 14 over Rationals>> ]
  !gapprompt@gap>| !gapinput@List( last, Dimension );|
  [ 14, 7, 1, 27 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CharacteristicsOfStrata}}
\logpage{[ 2, 2, 4 ]}\nobreak
\hyperdef{L}{X7889949D87615523}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CharacteristicsOfStrata({\mdseries\slshape L, hw})\index{CharacteristicsOfStrata@\texttt{CharacteristicsOfStrata}}
\label{CharacteristicsOfStrata}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a semisimple Lie algebra over a field of characteristic 0. Secondly, \mbox{\texttt{\mdseries\slshape hw}} is a dominant weight, represented as a list of non-negative integers (where
the ordering of the fundamantal weights is given by the Cartan matrix of the
root system of \mbox{\texttt{\mdseries\slshape L}}). Let $G$ denote the semisimple algebraic group acting on the irreducible representation
with highest weight \mbox{\texttt{\mdseries\slshape hw}}. Hesselink (\cite{hesselink}) defined a stratification of the nullcone relative to the action of $G$. Popov and Vinberg (\cite{povin}) have described this stratification in terms of characteristics, which are
elements of a Cartan subalgebra of \mbox{\texttt{\mdseries\slshape L}}. To each characteristic there corresponds a stratum. This function is an
implementation of an algorithm due to Popov (\cite{popov}), for computing the characteristics of the strata. It returns a list of two
lists. The first list contains the characteristics. The second list contains
the dimensions of the corresponding strata. If the highest weight \mbox{\texttt{\mdseries\slshape hw}} defines the adjoint representation, then the characteristics of the strata are
exactly the characteristics of the nilpotent orbits in \mbox{\texttt{\mdseries\slshape L}}. This means the following: let $h$ be a characteristic, then there are $e,f$ in \mbox{\texttt{\mdseries\slshape L}} such that the triple $h,e,f$ satisfies the commutation relations of $\mathfrak{sl}_2$, and the elements $e$ thus obtained are the representatives of the nilpotent $G$-orbits in \mbox{\texttt{\mdseries\slshape L}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("G",2,Rationals);;|
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("G",2,Rationals);;|
  !gapprompt@gap>| !gapinput@CharacteristicsOfStrata( L, [0,1] );|
  [ [ v.13+(2)*v.14, (2)*v.13+(3)*v.14, (2)*v.13+(4)*v.14, (6)*v.13+(10)*v.14 ],
    [ 6, 8, 10, 12 ] ]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Nilpotent Orbits}}\logpage{[ 3, 0, 0 ]}
\hyperdef{L}{X8295733081A2BFF8}{}
{
  This chapter contains functions for dealing with the nilpotent orbits of a
semisimple Lie algebra $K$ under its adjoint group $G$. We refer to the book by Collingwood and McGovern, \cite{colmcgov} (and the references therein) for an account of the theory of nilpotent orbits.
A nilpotent orbit has two important attributes: the weighted Dynkin diagram,
and an $sl_2$-triple. The weighted Dynkin diagram is represented by a list of integers in
\texttt{\symbol{123}}0,1,2\texttt{\symbol{125}} of length equal to the rank of
the Lie algebra. The i-th position in this list correponds to the i-th node of
the Dynkin diagram of the root system. The Dynkin diagram of the root system
is described by the Cartan matrix of the root system. Now in GAP this Cartan
matrix can be somewhat different from the more usual forms. This holds most
particularly for type F4, where the enumeration of the simple roots is rather
different from the one usually found. So when using the functions in this
chapter one should keep this in mind. 

 Every nilpotent orbit has an $sl_2$-triple, that is a triple $(y,h,x)$ of elements of the simple Lie algebra with $[x,y]=h$, $[h,x]=2x$, $[h,y]=-2y$. The nilpotent orbit corresponding to this is the orbit of the element x
under the action of the adjoint group. 

 Let $P$ be a parabolic subalgebra of $K$ (i.e., generated by the Cartan subalgebra of $K$, all positive root vectors, along with the negative simple root vectors
corresponding to a given subset of the basis of simple roots), $L$ the corresponding Levi subalgebra (i.e., the reductive part of $P$), and $N$ the nilradical of $P$. Let $ O_L$ be a nilpotent orbit in $L$. There exists a unique nilpotent orbit $O_K$ in $K$ such that the intersection of $O_K$ and $O_L + N$ is dense in the latter. In this situation $O_K$ is said to be \emph{induced} from $O_L$. Nilpotent orbits in $K$ which are not induced are said to be \emph{rigid}. 

 Now consider the variety of all $G$-orbits in $K$ of a given dimension $d$. The irreducible components of this variety are called the \emph{sheets} of $K$. Every sheet has a unique nilpotent orbit. Moreover this nilpotent orbit is
induced from an orbit $O_L$, and $O_L$ is rigid in $L$. So the sheets are parametrised by pairs $(L,O_L)$, where $L$ is a Levi subalgebra, and $O_L$ a rigid nilpotent orbit in it. This data can conveniently be given by a \emph{sheet diagram}: this is the Dynkin diagram of $K$, were the nodes that do \emph{not} correspond to simple roots of $L$ have label 2. So, leaving out the nodes with label 2, one obtains the Dynkin
diagram of $L$. The remaining labels in the sheet diagram then correspond to the weighted
Dynkin diagram of the nilpotent orbit $O_L$. Since this orbit is rigid, its weighted Dynki diagram has labels 0 or 1.
From that it follows that one can recover $L$ and $O_L$ from the sheet diagram. The \emph{rank} of a sheet is defined as the dimension of the centre of $L$, obviously that is equal to the number of 2's in the sheet diagram. 
\section{\textcolor{Chapter }{ The functions }}\logpage{[ 3, 1, 0 ]}
\hyperdef{L}{X8173135A7D187358}{}
{
  

\subsection{\textcolor{Chapter }{NilpotentOrbit}}
\logpage{[ 3, 1, 1 ]}\nobreak
\hyperdef{L}{X7A074A557A7347D2}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentOrbit({\mdseries\slshape L, wd})\index{NilpotentOrbit@\texttt{NilpotentOrbit}}
\label{NilpotentOrbit}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a simple Lie algebra and \mbox{\texttt{\mdseries\slshape wd}} a weighted Dynkin diagram (i.e., a list containing the weights of the weighted
Dynkin diagram, in the same order as the nodes of the Dynkin diagram of the
root system of \mbox{\texttt{\mdseries\slshape L}}; that order can be deduced from the Cartan matrix of the same root system).
The corresponding nilpotent orbit is returned. It is the responsibility of the
user to make sure that the weighted Dynkin diagram corresponds to a nilpotent
orbit. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@o:= NilpotentOrbit( L, [1,2,0,0,0,1] );|
  <nilpotent orbit in Lie algebra of type E6>
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{NilpotentOrbits}}
\logpage{[ 3, 1, 2 ]}\nobreak
\hyperdef{L}{X7D5C0354810069A8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentOrbits({\mdseries\slshape L})\index{NilpotentOrbits@\texttt{NilpotentOrbits}}
\label{NilpotentOrbits}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a semisimple Lie algebra. This function returns the list of all nilpotent
orbits of \mbox{\texttt{\mdseries\slshape L}}. If \mbox{\texttt{\mdseries\slshape L}} is simple of classical type, then the nilpotent orbits correpond to partitions
(of $n+1$ for type $A_n$, of $2n+1$ for type $B_n$, of $2n$ for type $C_n$ and of $2n$ for type $D_n$, see \cite{colmcgov}). If \mbox{\texttt{\mdseries\slshape L}} is of one of these types then the orbits returned by this function have the
attribute \mbox{\texttt{\mdseries\slshape OrbitPartition}} set, which returns the corresponding partition. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@orbs:= NilpotentOrbits(L);;|
  !gapprompt@gap>| !gapinput@orbs[10];|
  <nilpotent orbit in Lie algebra of type E6>
  !gapprompt@gap>| !gapinput@Length(orbs);|
  20
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("B",4,Rationals);;|
  !gapprompt@gap>| !gapinput@orbs:= NilpotentOrbits(L);;            |
  !gapprompt@gap>| !gapinput@OrbitPartition( orbs[10] );|
  [ 5, 2, 2 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{WeightedDynkinDiagram}}
\logpage{[ 3, 1, 3 ]}\nobreak
\hyperdef{L}{X804830757E5971E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightedDynkinDiagram({\mdseries\slshape o})\index{WeightedDynkinDiagram@\texttt{WeightedDynkinDiagram}}
\label{WeightedDynkinDiagram}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape o}} is a nilpotent orbit; this function returns its weighted Dynkin diagram. }

 

\subsection{\textcolor{Chapter }{WeightedDynkinDiagram}}
\logpage{[ 3, 1, 4 ]}\nobreak
\hyperdef{L}{X804830757E5971E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{WeightedDynkinDiagram({\mdseries\slshape L, x})\index{WeightedDynkinDiagram@\texttt{WeightedDynkinDiagram}}
\label{WeightedDynkinDiagram}
}\hfill{\scriptsize (method)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a semisimple Lie algebra, and \mbox{\texttt{\mdseries\slshape x}} a nilpotent element. This function returns the weighted Dynkin diagram of the
orbit containing \mbox{\texttt{\mdseries\slshape x}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("B",3,Rationals);;|
  !gapprompt@gap>| !gapinput@WeightedDynkinDiagram( L, L.1+L.9 ); |
  [ 2, 0, 0 ]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals );;|
  !gapprompt@gap>| !gapinput@WeightedDynkinDiagram(L, L.1+L.6+L.20+2*L.32 : table:= true );|
  [ 0, 0, 0, 1, 0, 0 ]
  !gapprompt@gap>| !gapinput@time;|
  2048
  !gapprompt@gap>| !gapinput@WeightedDynkinDiagram(L, L.1+L.6+L.20+2*L.32 : table:= true );|
  [ 0, 0, 0, 1, 0, 0 ]
  !gapprompt@gap>| !gapinput@time;|
  64
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{AmbientLieAlgebra}}
\logpage{[ 3, 1, 5 ]}\nobreak
\hyperdef{L}{X7F2B6308785707B9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AmbientLieAlgebra({\mdseries\slshape o})\index{AmbientLieAlgebra@\texttt{AmbientLieAlgebra}}
\label{AmbientLieAlgebra}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape o}} is a nilpotent orbit; this function returns the Lie algebra it lives in. }

 

\subsection{\textcolor{Chapter }{SemiSimpleType}}
\logpage{[ 3, 1, 6 ]}\nobreak
\hyperdef{L}{X8401CDC2859F8A85}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SemiSimpleType({\mdseries\slshape o})\index{SemiSimpleType@\texttt{SemiSimpleType}}
\label{SemiSimpleType}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape o}} is a nilpotent orbit; this function returns the type of the Lie algebra it
lives in. }

 

\subsection{\textcolor{Chapter }{SL2Triple}}
\logpage{[ 3, 1, 7 ]}\nobreak
\hyperdef{L}{X84E78DA17D8C7F74}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SL2Triple({\mdseries\slshape o})\index{SL2Triple@\texttt{SL2Triple}}
\label{SL2Triple}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape o}} is a nilpotent orbit; this function returns an sl{\textunderscore}2-triple $(y,h,x)$ corresponding to \mbox{\texttt{\mdseries\slshape o}}. For the exceptional types the $x$ is as in the paper \cite{wdg08}. For the classical types the $x$ is computed on the fly. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@orbs:= NilpotentOrbits(L);;|
  !gapprompt@gap>| !gapinput@SL2Triple( orbs[10] );|
  [ (4)*v.51+(3)*v.53+(3)*v.56+v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
      8)*v.77+(4)*v.78, v.15+v.17+v.20+v.23 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{RandomSL2Triple}}
\logpage{[ 3, 1, 8 ]}\nobreak
\hyperdef{L}{X832FB68587166C4F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RandomSL2Triple({\mdseries\slshape o})\index{RandomSL2Triple@\texttt{RandomSL2Triple}}
\label{RandomSL2Triple}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape o}} is a nilpotent orbit; this function returns a random
sl{\textunderscore}2-triple $(x,h,y)$ corresponding to \mbox{\texttt{\mdseries\slshape o}}. This means that every call (potentially) returns a different
sl{\textunderscore}2-triple. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@orbs:= NilpotentOrbits(L);;|
  !gapprompt@gap>| !gapinput@RandomSL2Triple( orbs[10] );|
  [ (3)*v.49+(3)*v.50+v.51+(4)*v.59, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
      8)*v.77+(4)*v.78, v.13+v.14+v.15+v.23 ]
  !gapprompt@gap>| !gapinput@RandomSL2Triple( orbs[10] );|
  [ (3)*v.50+(3)*v.53+v.54+(4)*v.57, (4)*v.73+(6)*v.74+(8)*v.75+(11)*v.76+(
      8)*v.77+(4)*v.78, v.14+v.17+v.18+v.21 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SL2Grading}}
\logpage{[ 3, 1, 9 ]}\nobreak
\hyperdef{L}{X8029297A7C3372E9}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SL2Grading({\mdseries\slshape L, h})\index{SL2Grading@\texttt{SL2Grading}}
\label{SL2Grading}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a Lie algebra, and \mbox{\texttt{\mdseries\slshape h}} is an element of it, such that there is an sl{\textunderscore}2 triple of
which it is the Cartan element (the system does not check that). This function
returns the grading of \mbox{\texttt{\mdseries\slshape L}} in eigenspaces of \mbox{\texttt{\mdseries\slshape h}}. A list containing three lists is returned: the first list contains bases of
the components with degrees 1,2,3,... the second list has bases of the
components with degrees -1,-2,-3,..., the last list contains a basis of the
zero component. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("F",4,Rationals);;|
  !gapprompt@gap>| !gapinput@orbs:= NilpotentOrbits(L);;|
  !gapprompt@gap>| !gapinput@sl2:= RandomSL2Triple( orbs[6] );|
  [ v.36+(2)*v.40+(2)*v.42, (3)*v.49+(4)*v.50+(6)*v.51+(8)*v.52, v.12+v.16+v.18 
   ]
  !gapprompt@gap>| !gapinput@SL2Grading( L, sl2[2] );|
  [ [ [ v.3, v.5, v.7, v.8, v.9, v.11 ], 
        [ v.10, v.12, v.13, v.14, v.15, v.16, v.17, v.18, v.20 ], 
        [ v.19, v.21 ], [ v.22, v.23, v.24 ] ], 
    [ [ v.27, v.29, v.31, v.32, v.33, v.35 ], 
        [ v.34, v.36, v.37, v.38, v.39, v.40, v.41, v.42, v.44 ], 
        [ v.43, v.45 ], [ v.46, v.47, v.48 ] ], 
    [ v.1, v.2, v.4, v.6, v.25, v.26, v.28, v.30, v.49, v.50, v.51, v.52 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SL2Triple}}
\logpage{[ 3, 1, 10 ]}\nobreak
\hyperdef{L}{X84E78DA17D8C7F74}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SL2Triple({\mdseries\slshape L, x})\index{SL2Triple@\texttt{SL2Triple}}
\label{SL2Triple}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a simple Lie algebra, and \mbox{\texttt{\mdseries\slshape x}} is a nilpotent element of it. A list of three elements is returned, forming an
sl{\textunderscore}2-triple, the last of which is equal to \mbox{\texttt{\mdseries\slshape x}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("F",4,Rationals);;|
  !gapprompt@gap>| !gapinput@SL2Triple( L, L.1+L.20 );|
  [ v.16+v.25, v.49, v.1+v.20 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{InducedNilpotentOrbits}}
\logpage{[ 3, 1, 11 ]}\nobreak
\hyperdef{L}{X830C432A838875A0}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InducedNilpotentOrbits({\mdseries\slshape L})\index{InducedNilpotentOrbits@\texttt{InducedNilpotentOrbits}}
\label{InducedNilpotentOrbits}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a simple Lie algebra. This function returns the list of all induced
nilpotent orbits of \mbox{\texttt{\mdseries\slshape L}}. An induced orbit is given by a record containing two fields: \mbox{\texttt{\mdseries\slshape sheetdiag}}, which is a diagram describing the Levi subalgebra and the rigid nilpotent
orbit in it from which the nilpotent orbit is induced, and \mbox{\texttt{\mdseries\slshape norbit}}, which is the induced nilpotent orbit in \mbox{\texttt{\mdseries\slshape L}}. The sheet diagram is a labeled Dynkin diagram, and the labels are 0, 1 or 2.
If we take the Dynkin diagram and erase the nodes which have label 2 then we
obtain the Dynkin diagram of the Levi subalgebra. Moreover, the labels 0 and 1
on that diagram give the rigid nilpotent orbit in the Levi subalgebra. From
this pair the nilpotent orbit \mbox{\texttt{\mdseries\slshape norbit}} is induced. It may happen that the same nilpotent orbit is induced from more
pairs consisting of a Levi subalgebra and a rigid nilpotent orbit in it. In
that case the same nilpotent orbit appears more than once in the list, each
time with a different sheet diagram attached. This function works for the Lie
algebras of exceptional type and for the Lie algebras of type $A$ regardless of the rank. It works for the Lie algebras of the other types up to
rank 10. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@s:= InducedNilpotentOrbits(L);;|
  !gapprompt@gap>| !gapinput@s[19];|
  rec( norbit := <nilpotent orbit in Lie algebra of type E6>, 
  sheetdiag := [ 2, 0, 0, 1, 0, 2 ] )
  !gapprompt@gap>| !gapinput@WeightedDynkinDiagram( s[19].norbit );|
  [ 0, 0, 0, 2, 0, 0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{RigidNilpotentOrbits}}
\logpage{[ 3, 1, 12 ]}\nobreak
\hyperdef{L}{X78795C607C2343C3}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RigidNilpotentOrbits({\mdseries\slshape L})\index{RigidNilpotentOrbits@\texttt{RigidNilpotentOrbits}}
\label{RigidNilpotentOrbits}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a simple Lie algebra. This function returns the list of all rigid nilpotent
orbits of \mbox{\texttt{\mdseries\slshape L}}, \emph{except} the zero orbit (which is always rigid). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@RigidNilpotentOrbits(L);|
  [ <nilpotent orbit in Lie algebra of type E6>, 
    <nilpotent orbit in Lie algebra of type E6>, 
    <nilpotent orbit in Lie algebra of type E6> ]
  !gapprompt@gap>| !gapinput@List( last, WeightedDynkinDiagram );|
  [ [ 0, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 1 ] ]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Finite Order Automorphisms and $\theta$-Groups}}\logpage{[ 4, 0, 0 ]}
\hyperdef{L}{X780235AD7DD9CBA9}{}
{
  This chapter contains functions for creating and working with finite order
automorphisms of simple Lie algebras (or, more precisely, representatives of
the conjugacy classes of such automorphisms). 

 NB: such automorphisms are not created for a given Lie algebra, but the Lie
algebra is constructed at the same time as the automorphism. This because the
base field may need extending (it needs enough roots of unity). 

 As noted above the functions give representatives of the conjugacy classes, in
the automorphism group of the underlying Lie algebra, of finite order
automorphisms. Such conjugacy classes are classified in terms of Kac diagrams.
Roughly, this works as follows. A finite order automorphism $f$ corresponds to a diagram automorphism of order $d=1,2,3$. The inner automorphisms correspond to a diagram automorphism of order 1, the
outer automorphisms to a diagram automorphism of order 2 or 3. Let $L_0, L_1$ denote the eigenspaces of the underlying Lie algebra $L$, with respect to the diagram automorphism, respectively corresponding to the
eigenvalues 1 and $w$ (where $w$ is a primitive $d$-th root of unity). (In case of $d=1$, we have $L_0=L$, $L_1=0$.) Then $L_0$ is semisimple and we choose a set of canonical generators of $L_0$, denoted $x_i$, $y_i$, $h_i$, for $i=1,\ldots,s$. Moreover, $L_1$ is an $L_0$-module. Let $x_0$ be the lowest weight vector in $L_1$. (If $d=1$ then $x_0$ will be the lowest (negative) root vector.) Let $\alpha_i$ for $i=0,\ldots,s$ be the roots corresponding to $x_i$, with respect to the subalgebra spanned by the $h_i$. Let $C$ be the Cartan matrix of these roots. The rows of $C$ are linearly dependent. The Dynkin diagram of $C$ is labeled with integers $a_i$ with greatest common divisor 1, that form the coefficients of a linear
dependency of the rows of $C$. Furthermore, the $x_i$ generate $L$ and the automorphism $f$ is described by $f(x_i) = v^{s_i} x_i $, where the non-negative integers $s_i$ have greatest common divisor 1, and are such that $m=d\sum a_i s_i$ is the order of $f$, and where $v$ is a primitive $m$-th order root of unity. Now the Kac diagram of the automorphism $f$ is the Dynkin diagram of $C$, labelled with the labels $s_i$. 
\section{\textcolor{Chapter }{ The functions }}\logpage{[ 4, 1, 0 ]}
\hyperdef{L}{X8173135A7D187358}{}
{
  

\subsection{\textcolor{Chapter }{FiniteOrderInnerAutomorphisms}}
\logpage{[ 4, 1, 1 ]}\nobreak
\hyperdef{L}{X856FF71D8565C1E5}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FiniteOrderInnerAutomorphisms({\mdseries\slshape type, rank, m})\index{FiniteOrderInnerAutomorphisms@\texttt{FiniteOrderInnerAutomorphisms}}
\label{FiniteOrderInnerAutomorphisms}
}\hfill{\scriptsize (operation)}}\\


 Let $L$ be the simple Lie algebra of type \mbox{\texttt{\mdseries\slshape type}} and rank \mbox{\texttt{\mdseries\slshape rank}}. The function returns representatives of the conjugacy classes of inner
automorphisms of $L$ of order \mbox{\texttt{\mdseries\slshape m}}. As noted also in the introduction to this chapter, this function constructs
the Lie algebra as well as the automorphisms (and the Lie algebra is
accessible through the source of these automorphisms). The reason for this is
that depending on the order of the automorphisms, the base field needs certain
roots of unity. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= FiniteOrderInnerAutomorphisms("E",6,3);|
  [ [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3)^2)*v.1, v.2, 
        v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
      [ v.72, (E(3))*v.1, (E(3))*v.2, v.3, v.4, v.5, v.6 ], 
    [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, v.1, (E(3))*v.2, 
        v.3, v.4, v.5, v.6 ], [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> 
      [ v.72, v.1, v.2, v.3, (E(3))*v.4, v.5, v.6 ], 
    [ v.72, v.1, v.2, v.3, v.4, v.5, v.6 ] -> [ (E(3))*v.72, (E(3))*v.1, v.2, 
        v.3, v.4, v.5, (E(3))*v.6 ] ]
  !gapprompt@gap>| !gapinput@Source(f[1]);|
  <Lie algebra of dimension 78 over CF(3)>
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{FiniteOrderOuterAutomorphisms}}
\logpage{[ 4, 1, 2 ]}\nobreak
\hyperdef{L}{X7E8CCC4885E2A443}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{FiniteOrderOuterAutomorphisms({\mdseries\slshape type, rank, m, d})\index{FiniteOrderOuterAutomorphisms@\texttt{FiniteOrderOuterAutomorphisms}}
\label{FiniteOrderOuterAutomorphisms}
}\hfill{\scriptsize (operation)}}\\


 Let $L$ be the simple Lie algebra of type \mbox{\texttt{\mdseries\slshape type}} and rank \mbox{\texttt{\mdseries\slshape rank}}. The function returns representatives of the conjugacy classes of outer
automorphisms of $L$ of order \mbox{\texttt{\mdseries\slshape m}}, corresponding to a diagram automorphism of order \mbox{\texttt{\mdseries\slshape d}}. }

 

\subsection{\textcolor{Chapter }{Order}}
\logpage{[ 4, 1, 3 ]}\nobreak
\hyperdef{L}{X84F59A2687C62763}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Order({\mdseries\slshape f})\index{Order@\texttt{Order}}
\label{Order}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is a finite order automorphism. This returns its order. }

 

\subsection{\textcolor{Chapter }{KacDiagram}}
\logpage{[ 4, 1, 4 ]}\nobreak
\hyperdef{L}{X8635ABCD7D5ACED8}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{KacDiagram({\mdseries\slshape f})\index{KacDiagram@\texttt{KacDiagram}}
\label{KacDiagram}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is a finite order automorphism. This returns its Kac diagram. This is a record
with three components: \mbox{\texttt{\mdseries\slshape CM}}, which is the Cartan matrix of the Dynkin diagram, \mbox{\texttt{\mdseries\slshape labels}} the integers with gcd equal to 1 that are the coefficients of a linear
dependency of the rows of \mbox{\texttt{\mdseries\slshape CM}}, and \mbox{\texttt{\mdseries\slshape weights}} that are the integers $s_i$ that define the automorphism. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= FiniteOrderOuterAutomorphisms( "A", 5, 4, 2 );;|
  !gapprompt@gap>| !gapinput@r:= KacDiagram( f[1] );|
  rec( 
    CM := [ [ 2, 0, -1, 0 ], [ 0, 2, -1, 0 ], [ -1, -1, 2, -1 ], [ 0, 0, -2, 2 
           ] ], labels := [ 1, 1, 2, 1 ], weights := [ 1, 1, 0, 0 ] )
  !gapprompt@gap>| !gapinput@r.labels*r.CM;      |
  [ 0, 0, 0, 0 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Grading}}
\logpage{[ 4, 1, 5 ]}\nobreak
\hyperdef{L}{X7DCA2568870A2D34}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Grading({\mdseries\slshape f})\index{Grading@\texttt{Grading}}
\label{Grading}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is a finite order automorphism of order $m$. This returns a list of length $m$. The $i$-th element contains a basis of the eigenspace of \mbox{\texttt{\mdseries\slshape f}} with eigenvalue $v^i$, where $v$ is a primitive $m$-th root of unity (i.e., \mbox{\texttt{\mdseries\slshape v=E(m)}}). }

 

\subsection{\textcolor{Chapter }{NilpotentOrbitsOfThetaRepresentation}}
\logpage{[ 4, 1, 6 ]}\nobreak
\hyperdef{L}{X7D9BDD03811B3C98}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentOrbitsOfThetaRepresentation({\mdseries\slshape f})\index{NilpotentOrbitsOfThetaRepresentation@\texttt{Nilpotent}\-\texttt{Orbits}\-\texttt{Of}\-\texttt{Theta}\-\texttt{Representation}}
\label{NilpotentOrbitsOfThetaRepresentation}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{NilpotentOrbitsOfThetaRepresentation({\mdseries\slshape L, d})\index{NilpotentOrbitsOfThetaRepresentation@\texttt{Nilpotent}\-\texttt{Orbits}\-\texttt{Of}\-\texttt{Theta}\-\texttt{Representation}}
\label{NilpotentOrbitsOfThetaRepresentation}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is an automorphism of a simple Lie algebra $L$ of order $m$. Then \mbox{\texttt{\mdseries\slshape f}} defines a grading on $L$. Let the homogeneous components of this grading be denoted $L_i$ for $i=0,...,m-1$. Let $G_0$ be the group corresponding to $L_0$ (i.e., the connected subgroup of the adjoint group of $L$ with Lie algebra $L_0$). This function computes representatives for the nilpotent orbits of $G_0$ acting on $L_1$. The output is a list of triples. Each triple is an $sl_2$-triple $(y,h,x)$, with $h\in L_0$, $x\in L_1$ (the representative of the orbit), and $y\in L_{m-1}$. The element $h$ also lies in the dominant Weyl chamber of a Cartan subalgebra of $L_0$. Finally we note that all elements lie in \mbox{\texttt{\mdseries\slshape Source( f )}}. 

 It is possible to add an extra optional argument: \mbox{\texttt{\mdseries\slshape method:= "Carrier"}}, or \mbox{\texttt{\mdseries\slshape method:= "WeylOrbit"}}. Then a method based on finding carrier algebras (respectively, computing
orbits under the Weyl group) is chosen. If no optional argument is chosen,
then the system will make its own choice. (In the case of outer automorphisms,
currently the only available method is the one based on orbits of the Weyl
group.) The method based on carrier algebras tends to work better for the
higher order automorphisms. 

 This function prints some information on what it is doing to the info class \mbox{\texttt{\mdseries\slshape InfoSLA}}. In order to suppress these messages one can do \mbox{\texttt{\mdseries\slshape SetInfoLevel( InfoSLA, 1 );}}. 

 In the two-argument version, the first argument \mbox{\texttt{\mdseries\slshape L}} has to be a semisimple Lie algebra, and the second argument \mbox{\texttt{\mdseries\slshape d}} a list of non-negative integers. Then \mbox{\texttt{\mdseries\slshape L}} is $Z$-graded by giving the root space corresponding to the $i$-th simple root the degree \mbox{\texttt{\mdseries\slshape d[i]}}. Apart from this the function works the same in this case as in the
one-argument version. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= FiniteOrderInnerAutomorphisms( "D", 5, 3 );;   |
  !gapprompt@gap>| !gapinput@s:= NilpotentOrbitsOfThetaRepresentation( f[2] : method:= "Carrier" );; time;|
  #I  Selected carrier algebra method.
  #I  Constructed 123 root bases of possible flat subalgebras, now checking them...
  #I  Obtained 30 Cartan elements, weeding out equivalent copies...
  776
  !gapprompt@gap>| !gapinput@Length(s);|
  10
  !gapprompt@gap>| !gapinput@s[4];|
  [ v.14+v.15+v.38, (-2)*v.41+(-1)*v.42, v.18+v.34+v.35 ]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@NilpotentOrbitsOfThetaRepresentation( L, [0,1,0,0,0,0] );|
  #I  Selected Weyl orbit method.
  #I  Constructed a Weyl transversal of 72 elements.
  #I  Obtained 5 Cartan elements, weeding out equivalent copies...
  [ [ v.65+v.66+v.67, (2)*v.73+(3)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
        v.29+v.30+v.31 ], 
    [ (2)*v.55+(2)*v.66, (2)*v.73+(4)*v.74+(4)*v.75+(6)*v.76+(4)*v.77+(2)*v.78, 
        v.19+v.30 ], 
    [ v.63+v.71, (2)*v.73+(2)*v.74+(3)*v.75+(4)*v.76+(3)*v.77+(2)*v.78, 
        v.27+v.35 ], [ v.71, v.73+v.74+(2)*v.75+(3)*v.76+(2)*v.77+v.78, v.35 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{ClosureDiagram}}
\logpage{[ 4, 1, 7 ]}\nobreak
\hyperdef{L}{X7D4106C37DBD0943}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ClosureDiagram({\mdseries\slshape L, f, s})\index{ClosureDiagram@\texttt{ClosureDiagram}}
\label{ClosureDiagram}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ClosureDiagram({\mdseries\slshape L, d, s})\index{ClosureDiagram@\texttt{ClosureDiagram}}
\label{ClosureDiagram}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is an automorphism of a simple Lie algebra $L$ of order $m$, and \mbox{\texttt{\mdseries\slshape s}} a list of $sl_2$-triples $(y,h,x)$, with $h\in L_0$, $x\in L_1$ (for instance as computed by the previous function), corresponding to
nilpotent orbits in $L_1$. 

 This function computes the Hasse diagram of the closures of the nilpotent
orbits. The output is a record with two components: \mbox{\texttt{\mdseries\slshape diag}} (which is a list of 2-tuples; a tuple \mbox{\texttt{\mdseries\slshape [ i, j ]}} means that orbit number \mbox{\texttt{\mdseries\slshape i}} is contained in the closure of orbit number \mbox{\texttt{\mdseries\slshape j}}), and \mbox{\texttt{\mdseries\slshape sl2}} (the same list of $sl_2$-triples, but sorted according to decreasing dimension, i.e., the highest
dimensional orbit comes first). The numbering used in the tuples in \mbox{\texttt{\mdseries\slshape diag}} corresponds to the order in which the orbits appear in the component \mbox{\texttt{\mdseries\slshape sl2}}. 

 During the execution of the program a message is printed. This message either
states that all inclusions have been proved, or lists a number of possible
inclusions, for which it could not be proved with absolute certainty that
these do not occur. This is due to the randomised nature of the algorithm: if
the algorithm finds an inclusion, then this inclusion is certain. However,
sometimes a non-inclusion can only be estabished by random methods, which
means that it is possible that there is an inclusion without the program
finding it. (This however, is very unlikely, and in practice almost never
happens.) Now showing that a non-inclusion really is a non-inclusion can be
done by computing the ranks of certain matrices with polynomial entries. In
principle \textsf{GAP} can do this; however, the system certainly is not very strong at it.
Therefore, as optional argument a filename can be given, by \mbox{\texttt{\mdseries\slshape filenm:= "file.m"}}. If this argument is present the program prints a Magma script in the file,
which can be loaded directly into the computer algebra system Magma. If the
output is always true, then all non-inclusions are proved. If there are non
non-inclusions to be proved, then the file is not written. 

 In the second version, the second argument \mbox{\texttt{\mdseries\slshape d}} is a list of non-negative integers. Then \mbox{\texttt{\mdseries\slshape L}} is $Z$-graded by giving the root space corresponding to the $i$-th simple root the degree \mbox{\texttt{\mdseries\slshape d[i]}}. Apart from this the function works in the same way. 

 We note that the adjoint representation can be obtained by giving a \mbox{\texttt{\mdseries\slshape d}} that eintirely consists of zeros. 
\begin{Verbatim}[commandchars=@|B,fontsize=\small,frame=single,label=Example]
  @gapprompt|gap>B @gapinput|f:= FiniteOrderInnerAutomorphisms( "E", 8, 8 );;  B
  @gapprompt|gap>B @gapinput|h:= f[8];;B
  @gapprompt|gap>B @gapinput|sl2:= NilpotentOrbitsOfThetaRepresentation(h);;  B
  #I  Selected carrier algebra method.
  #I  Constructed 2782 root bases of possible flat subalgebras, now checking them...
  #I  Obtained 58 Cartan elements, weeding out equivalent copies...
  @gapprompt|gap>B @gapinput|time;B
  117792
  @gapprompt|gap>B @gapinput|Length(sl2);B
  27
  @gapprompt|gap>B @gapinput|L:= Source(h);;                    B
  @gapprompt|gap>B @gapinput|r:= ClosureDiagram( L, h, sl2 );;  B
  #I  All (non-) inclusions proved!
  @gapprompt|gap>B @gapinput|time;B
  329248
  @gapprompt|gap>B @gapinput|r.diag;B
  [ [ 2, 1 ], [ 3, 1 ], [ 4, 2 ], [ 4, 3 ], [ 5, 1 ], [ 6, 5 ], [ 7, 2 ], [ 7, 5 ], 
  [ 8, 4 ], [ 9, 3 ], [ 9, 6 ], [ 10, 6 ], [ 10, 7 ], [ 11, 4 ], [ 11, 7 ], [ 12, 7 ], 
  [ 13, 9 ], [ 13, 10 ], [ 13, 11 ], [ 14, 11 ], [ 14, 12 ], [ 15, 6 ], [ 16, 8 ], 
  [ 16, 11 ], [ 17, 13 ], [ 17, 16 ], [ 18, 13 ], [ 18, 15 ], [ 19, 10 ], [ 19, 12 ], 
  [ 19, 15 ], [ 20, 14 ], [ 20, 16 ], [ 21, 9 ], [ 21, 15 ], [ 22, 14 ], [ 22, 18 ], 
  [ 22, 19 ], [ 23, 18 ], [ 23, 21 ], [ 24, 17 ], [ 24, 18 ], [ 25, 20 ], [ 25, 22 ], 
  [ 25, 24 ], [ 26, 22 ], [ 26, 23 ], [ 27, 23 ], [ 27, 24 ] ]
  # Now we do the adjoint representation of the Lie algebra of type F4:
  @gapprompt|gap>B @gapinput|L:= SimpleLieAlgebra("F",4,Rationals);;B
  @gapprompt|gap>B @gapinput|o:= NilpotentOrbits(L);;B
  @gapprompt|gap>B @gapinput|sl2:= List( o, SL2Triple );;B
  @gapprompt|gap>B @gapinput|r:= ClosureDiagram( L, [0,0,0,0], sl2 );;      B
  #I  All (non-) inclusions proved!
  @gapprompt|gap>B @gapinput|r.diag;B
  [ [ 2, 1 ], [ 3, 2 ], [ 4, 3 ], [ 5, 3 ], [ 6, 5 ], [ 6, 4 ], [ 7, 6 ], [ 8, 7 ], 
    [ 9, 7 ], [ 10, 9 ], [ 10, 8 ], [ 11, 8 ], [ 12, 10 ], [ 13, 12 ], [ 13, 11 ], 
    [ 14, 13 ], [ 15, 14 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CarrierAlgebra}}
\logpage{[ 4, 1, 8 ]}\nobreak
\hyperdef{L}{X8108B6487A3A363B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CarrierAlgebra({\mdseries\slshape L, f, e})\index{CarrierAlgebra@\texttt{CarrierAlgebra}}
\label{CarrierAlgebra}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CarrierAlgebra({\mdseries\slshape L, d, e})\index{CarrierAlgebra@\texttt{CarrierAlgebra}}
\label{CarrierAlgebra}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is an automorphism of a simple Lie algebra $L$ of order $m$, and \mbox{\texttt{\mdseries\slshape e}} a nilpotent element of $L_1$. This function returns the carrier algebra of \mbox{\texttt{\mdseries\slshape e}}. This is a $\mathbb{Z}$-graded semisimple subalgebra $K$ of $L$, such that \mbox{\texttt{\mdseries\slshape e}} lies in $K_1$. For the precise definition we refer to \cite{vinberg2}, \cite{vinberg3}. The output is given in the form of a record, with three components: \mbox{\texttt{\mdseries\slshape g0}}, a basis of $K_0$, \mbox{\texttt{\mdseries\slshape gp}} a list containing bases of $K_1$, $K_2$ and so on, and \mbox{\texttt{\mdseries\slshape gn}} a list containing bases of $K_{-1}$, $K_{-2}$ and so on. 

 In the second version, the second argument \mbox{\texttt{\mdseries\slshape d}} is a list of non-negative integers. Then \mbox{\texttt{\mdseries\slshape L}} is $Z$-graded by giving the root space corresponding to the $i$-th simple root the degree \mbox{\texttt{\mdseries\slshape d[i]}}. Apart from this the function works in the same way. 

 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= FiniteOrderInnerAutomorphisms( "F", 4, 5 );;|
  !gapprompt@gap>| !gapinput@h:= f[4];;|
  !gapprompt@gap>| !gapinput@sl2:= NilpotentOrbitsOfThetaRepresentation( h );;  |
  #I  Selected Weyl orbit method.
  #I  Constructed a Weyl transversal of 144 elements.
  #I  Constructed 621 Cartan elements to be checked.
  !gapprompt@gap>| !gapinput@L:= Source(h);   |
  <Lie algebra of dimension 52 over CF(5)>
  !gapprompt@gap>| !gapinput@r:=CarrierAlgebra( L, h, sl2[1][3] );   |
  rec( g0 := [ v.49+(2)*v.50+(2)*v.51+(3)*v.52, v.50+(1/2)*v.51+v.52 ], 
  gp := [ [ v.9, v.48 ], [ v.45 ], [ v.39 ] ], 
  gn := [ [ v.24, v.33 ], [ v.21 ], [ v.15 ] ] )
  !gapprompt@gap>| !gapinput@K:= Subalgebra( L, Concatenation( r.g0, Flat(r.gp), Flat(r.gn) ) );|
  <Lie algebra over CF(5), with 10 generators>
  !gapprompt@gap>| !gapinput@SemiSimpleType( K );|
  "B2"
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{CartanSubspace}}
\logpage{[ 4, 1, 9 ]}\nobreak
\hyperdef{L}{X7A8D86667BC7C033}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{CartanSubspace({\mdseries\slshape f})\index{CartanSubspace@\texttt{CartanSubspace}}
\label{CartanSubspace}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape f}} is an automorphism of a simple Lie algebra $L$ of order $m$. Then \mbox{\texttt{\mdseries\slshape f}} defines a grading on $L$. Let the homogeneous components of this grading be denoted $L_i$ for $i=0,...,m-1$. Let $G_0$ be the group corresponding to $L_0$ (i.e., the connected subgroup of the adjoint group of $L$ with Lie algebra $L_0$). This function computes a maximal subspace of $L_1$ consisting of commuting semisimple elements. (Such a subspace is called a \emph{Cartan subspace}.) 

 Every semisimple orbit of $G_0$ in $L_1$ contains an element of a fixed Cartan subspace. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@f:= FiniteOrderInnerAutomorphisms( "A", 3, 3 );;|
  !gapprompt@gap>| !gapinput@c:= CartanSubspace( f[3] ); |
  <vector space of dimension 1 over CF(3)>
  !gapprompt@gap>| !gapinput@BasisVectors( Basis( c ) );|
  [ v.1+v.5+v.12 ]
\end{Verbatim}
 }

 }

 }

 
\chapter{\textcolor{Chapter }{Semisimple Subalgebras of Semisimple Lie Algebras}}\logpage{[ 5, 0, 0 ]}
\hyperdef{L}{X7FF8A8057E0BFAFD}{}
{
  This chapter contains functions for dealing with semisimple subalgebras of
semisimple Lie algebras. There are functions for computing branching rules,
for computing the regular subalgebras, and for working with the database of
semisimple subalgebras of the simple Lie algebras. This last database contains
the semisimple subalgebras of the simple Lie algebras of ranks up to 8. The
semisimple subalgebras are classified up to linear equivalence. (Two
subalgebras are called linearly equivalent if for every representation of the
big algebra in the space $V$ the images of the subalgebras are conjugate under $GL(V)$.) 
\section{\textcolor{Chapter }{ Branching }}\logpage{[ 5, 1, 0 ]}
\hyperdef{L}{X806713FE83F21540}{}
{
  

\subsection{\textcolor{Chapter }{ProjectionMatrix}}
\logpage{[ 5, 1, 1 ]}\nobreak
\hyperdef{L}{X8147807D7B92C613}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{ProjectionMatrix({\mdseries\slshape L, K})\index{ProjectionMatrix@\texttt{ProjectionMatrix}}
\label{ProjectionMatrix}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} and \mbox{\texttt{\mdseries\slshape K}} are semisimple Lie algebras with the following properties: \mbox{\texttt{\mdseries\slshape K}} is contained in \mbox{\texttt{\mdseries\slshape L}}, the Cartan subalgebra of \mbox{\texttt{\mdseries\slshape L}}, as returned by \mbox{\texttt{\mdseries\slshape CartanSubalgebra(L)}} is split (this is automatic if \mbox{\texttt{\mdseries\slshape L}} is created by the built in \textsf{GAP} function) and \mbox{\texttt{\mdseries\slshape K}} has a Cartan subalgebra that is a subalgebra of the Cartan subalgebra of \mbox{\texttt{\mdseries\slshape L}}. We note that the function checks only the last property. The function
returns a matrix \mbox{\texttt{\mdseries\slshape P}} such that if \mbox{\texttt{\mdseries\slshape u}} is a weight of a \mbox{\texttt{\mdseries\slshape L}}-module $V$, then \mbox{\texttt{\mdseries\slshape P*u}} is a weight of \mbox{\texttt{\mdseries\slshape V}}, when considered as a \mbox{\texttt{\mdseries\slshape K}}-module. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",7,Rationals);;                |
  !gapprompt@gap>| !gapinput@K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               |
  !gapprompt@>| !gapinput@L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;|
  !gapprompt@gap>| !gapinput@Dimension(K);|
  63
  !gapprompt@gap>| !gapinput@SemiSimpleType(K);|
  "A7"
  !gapprompt@gap>| !gapinput@ProjectionMatrix( L, K );|
  [ [ 2, 2, 3, 4, 3, 2, 1 ], [ 0, 0, -1, 0, 0, 0, 0 ], [ 0, 0, 0, -1, 0, 0, 0 ],
    [ 0, 0, 0, 0, -1, 0, 0 ], [ 0, 0, 0, 0, 0, -1, 0 ], 
    [ 0, 0, 0, 0, 0, 0, -1 ], [ -1, -2, -2, -3, -2, -1, 0 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{Branching}}
\logpage{[ 5, 1, 2 ]}\nobreak
\hyperdef{L}{X806713FE83F21540}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{Branching({\mdseries\slshape L, K, hw})\index{Branching@\texttt{Branching}}
\label{Branching}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} and \mbox{\texttt{\mdseries\slshape K}} are as in the previous function, and \mbox{\texttt{\mdseries\slshape hw}} is the highest weight of an irreducible \mbox{\texttt{\mdseries\slshape L}}-module. This function computes the splitting of the module when seen as a \mbox{\texttt{\mdseries\slshape K}}-module. Returned is a list of two lists: the first list contains the highest
weights of the modules involved, the second list contains their
multiplicities. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",7,Rationals);;                |
  !gapprompt@gap>| !gapinput@K:= Subalgebra( L, [ L.1,L.3,L.4,L.5,L.6,L.7,L.63,               |
  !gapprompt@>| !gapinput@L.64,L.66,L.67,L.68,L.69,L.70,L.126] );;|
  !gapprompt@gap>| !gapinput@Branching( L, K, [1,0,0,0,0,0,1] );|
  [ [ [ 1, 1, 0, 0, 0, 0, 1 ], [ 1, 1, 1, 0, 0, 0, 0 ], [ 0, 0, 0, 0, 1, 0, 1 ],
        [ 0, 0, 1, 0, 1, 0, 0 ], [ 1, 0, 0, 1, 0, 0, 0 ], 
        [ 0, 1, 0, 0, 0, 1, 0 ], [ 0, 0, 0, 0, 0, 0, 1 ], 
        [ 0, 0, 1, 0, 0, 0, 0 ] ], [ 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 }

 }

 
\section{\textcolor{Chapter }{ Constructing Semisimple Subalgebras }}\logpage{[ 5, 2, 0 ]}
\hyperdef{L}{X7CC8010B7F31B486}{}
{
  

\subsection{\textcolor{Chapter }{RegularSemisimpleSubalgebras}}
\logpage{[ 5, 2, 1 ]}\nobreak
\hyperdef{L}{X7E95AD2C79B19D15}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{RegularSemisimpleSubalgebras({\mdseries\slshape L})\index{RegularSemisimpleSubalgebras@\texttt{RegularSemisimpleSubalgebras}}
\label{RegularSemisimpleSubalgebras}
}\hfill{\scriptsize (attribute)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a \emph{simple} Lie algebra. This function returns a list of its conjugacy classes of
semisimple subalgebras (conjugacy under the adjoint group). 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@L:= SimpleLieAlgebra("E",6,Rationals);;|
  !gapprompt@gap>| !gapinput@K:= RegularSemisimpleSubalgebras( L );; time;|
  1664
  !gapprompt@gap>| !gapinput@Length(K);|
  19
  !gapprompt@gap>| !gapinput@K[5];|
  <Lie algebra of dimension 45 over Rationals>
  !gapprompt@gap>| !gapinput@SemiSimpleType( K[5] ); |
  "D5"
  !gapprompt@gap>| !gapinput@Branching( L, K[5], [1,0,0,0,0,1] );     |
  [ [ [ 1, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 1 ], [ 1, 0, 0, 1, 0 ], 
        [ 1, 0, 0, 0, 1 ], [ 2, 0, 0, 0, 0 ], [ 0, 0, 0, 1, 0 ], 
        [ 0, 0, 0, 0, 1 ], [ 0, 1, 0, 0, 0 ], [ 0, 0, 0, 0, 0 ] ], 
    [ 2, 1, 1, 1, 1, 1, 1, 1, 1 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SSSTypes}}
\logpage{[ 5, 2, 2 ]}\nobreak
\hyperdef{L}{X857808A77C13E46C}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SSSTypes({\mdseries\slshape })\index{SSSTypes@\texttt{SSSTypes}}
\label{SSSTypes}
}\hfill{\scriptsize (function)}}\\


 This returns a list of the types of the semisimple Lie algebras of which the
database contains the classification of the semisimple subalgebras, up to
linear equivalence. (The three letters S stand for SemiSimple Subalgebras.) }

 

\subsection{\textcolor{Chapter }{LieAlgebraAndSubalgebras}}
\logpage{[ 5, 2, 3 ]}\nobreak
\hyperdef{L}{X832B17BA819FB057}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{LieAlgebraAndSubalgebras({\mdseries\slshape type})\index{LieAlgebraAndSubalgebras@\texttt{LieAlgebraAndSubalgebras}}
\label{LieAlgebraAndSubalgebras}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape type}} is a string describing the type of a semisimple Lie algebra. A simple type is
a capital letter (A, B, C, D, E, F, or G) followed by a positive integer.
Example: \mbox{\texttt{\mdseries\slshape "D5"}}. In general a type is a sequence of simple types separated by spaces.
Example: \mbox{\texttt{\mdseries\slshape "A2 C3 E6"}}. This function is appliccable if each simple type that occurs in \mbox{\texttt{\mdseries\slshape type}} has rank less than or equal to 8. In that case a record is returned with two
components: \mbox{\texttt{\mdseries\slshape liealg}}, which is a semisimple Lie algebra of type \mbox{\texttt{\mdseries\slshape type}}, and \mbox{\texttt{\mdseries\slshape subalgs}} which is the list of its semisimple subalgebras up to linear equivalence. If \mbox{\texttt{\mdseries\slshape type}} is a simple type then the list will be simply fetched from the database.
Otherwise a computation will be triggered, and afterwards the database will be
bigger. (One can check this with a call to \mbox{\texttt{\mdseries\slshape SSSTypes()}}). Also we remark that for non-simple types of not so small rank this
computation can be difficult. }

 

\subsection{\textcolor{Chapter }{InclusionsGraph}}
\logpage{[ 5, 2, 4 ]}\nobreak
\hyperdef{L}{X82ECC8237E213AAB}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{InclusionsGraph({\mdseries\slshape type})\index{InclusionsGraph@\texttt{InclusionsGraph}}
\label{InclusionsGraph}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape type}} is a string describing the type of a semisimple Lie algebra. This is the same
as in the previous function. This function returns a list containing the edges
of the inclusion graph of the semisimple subalgebras returned by the previous
function. An edge is represented by a list of two integers. If the edge \mbox{\texttt{\mdseries\slshape [ i, j ]}} occurs, then this means that the subalgebra on position \mbox{\texttt{\mdseries\slshape j}} in the list is linearly equivalent to a subalgebra of the subalgebra in
position \mbox{\texttt{\mdseries\slshape i}}. Only the maximal subalgebras are considered; so if we have edges \mbox{\texttt{\mdseries\slshape [ i, j ]}} and \mbox{\texttt{\mdseries\slshape [ j, k ]}} then there will be no edge \mbox{\texttt{\mdseries\slshape [ i, k ]}}. (Otherwise this list can become huge.) Edges of the form \mbox{\texttt{\mdseries\slshape [ 0, j ]}} express that the subalgebra on position \mbox{\texttt{\mdseries\slshape j}} is a maximal semisimple subalgebra of the Lie algebra of type \mbox{\texttt{\mdseries\slshape type}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  # Semisimple subalgebras of the Lie algebra of type D4:
  !gapprompt@gap>| !gapinput@s:= LieAlgebraAndSubalgebras( "D4" );;|
  !gapprompt@gap>| !gapinput@L:= s.liealg;|
  <Lie algebra of dimension 28 over CF(3)>
  !gapprompt@gap>| !gapinput@sub:= s.subalgs;;|
  !gapprompt@gap>| !gapinput@Length(sub);|
  44
  !gapprompt@gap>| !gapinput@g:= InclusionsGraph( "D4" );;|
  !gapprompt@gap>| !gapinput@g[1];|
  [ 12, 1 ]
  
  # Find the maximal semisimple subalgebras:
  
  !gapprompt@gap>| !gapinput@m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );|
  [ 13, 35, 36, 37, 41, 42, 43, 44 ]
  !gapprompt@gap>| !gapinput@List( sub{i}, SemiSimpleType );                |
  [ "A2", "A1 B2", "A1 B2", "A1 B2", "B3", "B3", "B3", "A1 A1 A1 A1" ]
  
  # We see that the subalgebras on positions 35 and 36 are isomorphic;
  # however they are not linearly equivalent:
  !gapprompt@gap>| !gapinput@Branching( L, sub[35], [0,0,1,0] );|
  [ [ [ 1, 0, 1 ] ], [ 1 ] ]
  !gapprompt@gap>| !gapinput@Branching( L, sub[36], [0,0,1,0] );|
  [ [ [ 0, 1, 0 ], [ 2, 0, 0 ] ], [ 1, 1 ] ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{SubalgebrasInclusion}}
\logpage{[ 5, 2, 5 ]}\nobreak
\hyperdef{L}{X7C81C2B57D94EC2B}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{SubalgebrasInclusion({\mdseries\slshape L, K1, K2})\index{SubalgebrasInclusion@\texttt{SubalgebrasInclusion}}
\label{SubalgebrasInclusion}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape K1}}, \mbox{\texttt{\mdseries\slshape K2}}, are two subalgebras of the semisimple Lie algebra \mbox{\texttt{\mdseries\slshape L}}, constructed using the database. If \mbox{\texttt{\mdseries\slshape K2}} contains a subalgebra that is linearly equivalent to \mbox{\texttt{\mdseries\slshape K1}} then such a subalgebra is returned. Otherwise the result is \mbox{\texttt{\mdseries\slshape fail}}. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s:= LieAlgebraAndSubalgebras( "C3" );;|
  !gapprompt@gap>| !gapinput@g:= InclusionsGraph( "C3" );|
  [ [ 10, 1 ], [ 11, 1 ], [ 12, 1 ], [ 8, 2 ], [ 10, 2 ], [ 11, 2 ], [ 11, 3 ], 
    [ 13, 3 ], [ 8, 4 ], [ 13, 4 ], [ 9, 5 ], [ 12, 5 ], [ 12, 6 ], [ 13, 6 ], 
    [ 0, 7 ], [ 0, 8 ], [ 15, 9 ], [ 9, 10 ], [ 14, 10 ], [ 14, 11 ], 
    [ 15, 12 ], [ 0, 13 ], [ 15, 14 ], [ 0, 15 ] ]
  # there are the edges [ 14, 10] and [ 10, 2 ]; hence a conjugate of the
  # second algebra is contained in the 14-th.
  !gapprompt@gap>| !gapinput@L:= s.liealg;|
  <Lie algebra of dimension 21 over Rationals>
  !gapprompt@gap>| !gapinput@sub:= s.subalgs;;|
  !gapprompt@gap>| !gapinput@K:=SubalgebrasInclusion( L, sub[2], sub[14] );|
  <Lie algebra of dimension 3 over Rationals>
  !gapprompt@gap>| !gapinput@Basis(K)[1] in sub[14];|
  true
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{DynkinIndex}}
\logpage{[ 5, 2, 6 ]}\nobreak
\hyperdef{L}{X82458B807A8D77F6}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{DynkinIndex({\mdseries\slshape K, L})\index{DynkinIndex@\texttt{DynkinIndex}}
\label{DynkinIndex}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape K}} is a semisimple subalgebra of the \emph{simple} Lie algebra \mbox{\texttt{\mdseries\slshape L}}. This function returns a list of integers, containing the Dynkin indices of
the simple components of \mbox{\texttt{\mdseries\slshape K}}. If the input Lie algebra \mbox{\texttt{\mdseries\slshape L}} is not simple, then still a list of rationals is returned, but they may have
no meaning. The Dynkin index is defined as follows. Consider a simple
component in \mbox{\texttt{\mdseries\slshape K}} and let $h$ be the coroot of the shortest root of \mbox{\texttt{\mdseries\slshape K}}. Let $k$ denote the Killing form of \mbox{\texttt{\mdseries\slshape L}}, normalised so that the coroot of the shortest root of \mbox{\texttt{\mdseries\slshape L}} has squared length 2. Then the Dynkin index is $k(h,h)/2$. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@s:= LieAlgebraAndSubalgebras( "C7" );;|
  !gapprompt@gap>| !gapinput@g:= InclusionsGraph( "C7" );;|
  !gapprompt@gap>| !gapinput@m:= Filtered( g, x -> x[1]=0 );; i:= List( m, x -> x[2] );|
  [ 63, 498, 665, 804, 819, 821, 822 ]
  !gapprompt@gap>| !gapinput@L:= s.liealg;|
  <Lie algebra of dimension 105 over Rationals>
  !gapprompt@gap>| !gapinput@sub:= s.subalgs;;|
  !gapprompt@gap>| !gapinput@List( sub{i}, SemiSimpleType );   |
  [ "A1", "C3", "A1 B3", "A6", "C3 C4", "B2 C5", "A1 C6" ]
  !gapprompt@gap>| !gapinput@DynkinIndex( sub[665], L );   |
  [ 7, 4 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{AreLinearlyEquivalentSubalgebras}}
\logpage{[ 5, 2, 7 ]}\nobreak
\hyperdef{L}{X7AAE2B317A4B7D9F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AreLinearlyEquivalentSubalgebras({\mdseries\slshape L, K1, K2})\index{AreLinearlyEquivalentSubalgebras@\texttt{AreLinearlyEquivalentSubalgebras}}
\label{AreLinearlyEquivalentSubalgebras}
}\hfill{\scriptsize (operation)}}\\


 Here \mbox{\texttt{\mdseries\slshape L}} is a semisimple Lie algebra, and \mbox{\texttt{\mdseries\slshape K1}}, \mbox{\texttt{\mdseries\slshape K2}} are subalgebras. It is assumed that the Cartan subalgebras (as returned by \mbox{\texttt{\mdseries\slshape CartanSubalgebra}}) of \mbox{\texttt{\mdseries\slshape K1}}, \mbox{\texttt{\mdseries\slshape K2}} are contained in the Cartan subalgebra of \mbox{\texttt{\mdseries\slshape L}} (otherwise \mbox{\texttt{\mdseries\slshape fail}} is returned). This function returns \mbox{\texttt{\mdseries\slshape true}} if \mbox{\texttt{\mdseries\slshape K1}}, \mbox{\texttt{\mdseries\slshape K2}} are linearly equivalent, \mbox{\texttt{\mdseries\slshape false }} otherwise. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  # Lets find the subalgebras in the database for C5 that are linearly
  # equivalent to regular subalgebras:
  !gapprompt@gap>| !gapinput@s:= LieAlgebraAndSubalgebras("C5");; L:= s.liealg; sub:= s.subalgs;;|
  <Lie algebra of dimension 55 over Rationals>
  !gapprompt@gap>| !gapinput@reg:= RegularSemisimpleSubalgebras( L );;|
  !gapprompt@gap>| !gapinput@posn:= [];;|
  !gapprompt@gap>| !gapinput@for K in reg do  |
  !gapprompt@>| !gapinput@Add(posn,PositionProperty(sub,M -> AreLinearlyEquivalentSubalgebras(L,M,K)));|
  !gapprompt@>| !gapinput@od;|
  !gapprompt@gap>| !gapinput@posn;|
  [ 2, 24, 93, 111, 105, 82, 106, 81, 41, 109, 70, 85, 29, 112, 94, 25, 1, 118, 
    100, 102, 64, 108, 84, 28, 117, 107, 116, 96, 101, 63, 115, 114, 95, 113 ]
\end{Verbatim}
 }

 

\subsection{\textcolor{Chapter }{MakeDatabaseEntry}}
\logpage{[ 5, 2, 8 ]}\nobreak
\hyperdef{L}{X7B1A01FE86A7718F}{}
{\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{MakeDatabaseEntry({\mdseries\slshape r})\index{MakeDatabaseEntry@\texttt{MakeDatabaseEntry}}
\label{MakeDatabaseEntry}
}\hfill{\scriptsize (operation)}}\\
\noindent\textcolor{FuncColor}{$\triangleright$\ \ \texttt{AddToDatabase({\mdseries\slshape d})\index{AddToDatabase@\texttt{AddToDatabase}}
\label{AddToDatabase}
}\hfill{\scriptsize (operation)}}\\


 These are functions that help to save a computed list of subalgebras of a
semisimple Lie algebra in a file, and in a new session, read it again. In the
first function \mbox{\texttt{\mdseries\slshape r}} is a record as produced by \texttt{LieAlgebraAndSubalgebras} (\ref{LieAlgebraAndSubalgebras}). It returns a record that can be saved in a file. (It is not advisable to
print it on the screen.) In the second function \mbox{\texttt{\mdseries\slshape d}} is a record that is output by \texttt{MakeDatabaseEntry}. This function adds this entry to the database. 

 We give two examples; in the first one we create a new database entry, and
save it to a file. In the second example we read it and add it to the
database. 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@r:= LieAlgebraAndSubalgebras( "A2 B2" );;|
  !gapprompt@gap>| !gapinput@d:= MakeDatabaseEntry( r );;|
  !gapprompt@gap>| !gapinput@PrintTo( "A2B2", "d:= ",d,";\n");|
\end{Verbatim}
 
\begin{Verbatim}[commandchars=!@|,fontsize=\small,frame=single,label=Example]
  !gapprompt@gap>| !gapinput@Read("A2B2");|
  !gapprompt@gap>| !gapinput@AddToDatabase( d );|
  !gapprompt@gap>| !gapinput@SSSTypes();|
  [ "A1", "A2", "B2", "G2", "A3", "B3", "C3", "A4", "B4", "C4", "D4", "F4", 
    "A5", "B5", "C5", "D5", "A6", "B6", "C6", "D6", "E6", "A7", "B7", "C7", 
    "D7", "E7", "A8", "B8", "C8", "D8", "E8", "A2 B2" ]
\end{Verbatim}
 }

 }

 }

 \def\bibname{References\logpage{[ "Bib", 0, 0 ]}
\hyperdef{L}{X7A6F98FD85F02BFE}{}
}

\bibliographystyle{alpha}
\bibliography{sla}

\addcontentsline{toc}{chapter}{References}

\def\indexname{Index\logpage{[ "Ind", 0, 0 ]}
\hyperdef{L}{X83A0356F839C696F}{}
}

\cleardoublepage
\phantomsection
\addcontentsline{toc}{chapter}{Index}


\printindex

\newpage
\immediate\write\pagenrlog{["End"], \arabic{page}];}
\immediate\closeout\pagenrlog
\end{document}
